<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mrbinbindeng</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Mrbinbindeng">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mrbinbindeng">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mrbinbindeng">
  
    <link rel="alternative" href="/atom.xml" title="Mrbinbindeng" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars1.githubusercontent.com/u/22582433?v=3&amp;s=460" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Dengbinbin</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Mrbinbindeng" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/winnerweb/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Dengbinbin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars1.githubusercontent.com/u/22582433?v=3&amp;s=460" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Dengbinbin</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Mrbinbindeng" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-webpack工具的使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/20/webpack工具的使用/" class="article-date">
  	<time datetime="2016-05-20T13:53:21.000Z" itemprop="datePublished">2016-05-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/20/webpack工具的使用/">
        webpack工具的使用
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><ul>
<li><p><a href="http://webpack.github.io" target="_blank" rel="external">官方网站</a></p>
</li>
<li><p>webpack 最终会把所有js文件合并在一起!</p>
</li>
<li>开发时可以单独开发</li>
</ul>
<h2 id="02-button"><a href="#02-button" class="headerlink" title="02.button"></a>02.button</h2><ul>
<li><ol>
<li>获取dom对象</li>
</ol>
</li>
<li><ol>
<li>给这个对象设置value值</li>
</ol>
</li>
<li><ol>
<li>给这个对象注册事件</li>
</ol>
</li>
</ul>
<h2 id="03-使用配置文件的方式使用webpack"><a href="#03-使用配置文件的方式使用webpack" class="headerlink" title="03 使用配置文件的方式使用webpack"></a>03 使用配置文件的方式使用webpack</h2><ul>
<li>webpack会自动读取这个文件里的配置。</li>
</ul>
<p>// webpack.config.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line">    <span class="built_in">module</span>.exports=&#123;</div><div class="line">  <span class="comment">// 是我们文件的入口</span></div><div class="line">  entry: path.resolve(__dirname, <span class="string">'./index.js'</span>),</div><div class="line">  <span class="attr">output</span>:&#123;</div><div class="line">    <span class="comment">// 输出文件的路径</span></div><div class="line">    path:__dirname,</div><div class="line">    <span class="attr">filename</span>:<span class="string">'bundle.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><ul>
<li>每一个loader都一个npm 包，需要通过npm 下载之后再使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>:&#123;</div><div class="line">  <span class="attr">loaders</span>:[</div><div class="line">    &#123;</div><div class="line">      <span class="attr">loader</span>:<span class="string">'css-loader'</span>,</div><div class="line">      <span class="attr">test</span>:<span class="regexp">/\.css$/</span>   <span class="comment">// 指定要处理的文件</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h3><ul>
<li>下载: <code>npm install css-loader --save-dev</code></li>
<li>作用:<ul>
<li>把css内容添加到js中，以字符串的形式存在!</li>
<li>也可以处理css中文件的引用:如:  @import ‘./base.css’</li>
</ul>
</li>
</ul>
<h3 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h3><ul>
<li>下载: <code>npm install style-loader --save-dev</code></li>
<li>作用: <ul>
<li>把css-loader处理的结果，添加到页面，使它的样式生效<ul>
<li>就是创建了一个style标签，添加内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>:&#123;</div><div class="line">  <span class="attr">loaders</span>:[</div><div class="line">    &#123;</div><div class="line">      <span class="attr">loader</span>:<span class="string">'style-loader!css-loader'</span> ,<span class="comment">// ! 可以理解为把右侧模块处理的结果，次给左侧</span></div><div class="line">      test:<span class="regexp">/\.css$/</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h3><ul>
<li>下载: <code>npm install sass-loader --save-dev</code><ul>
<li>如果是node 5.0及以的版本还需要下一个依赖包, node-sass</li>
</ul>
</li>
<li>作用: 是把scss文件内容，处理成css内容.</li>
<li>使用: 需要配合,css-loader 和style-loader 共同使用!</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>:&#123;</div><div class="line">  <span class="attr">loaders</span>:[</div><div class="line">     &#123;</div><div class="line">      <span class="attr">test</span>:<span class="regexp">/\.scss$/</span>,</div><div class="line"></div><div class="line">      <span class="comment">// 从右往左执行，右边处理完的结果，会交给左边模块处理</span></div><div class="line">      loader:<span class="string">'style-loader!css-loader!sass-loader'</span></div><div class="line">     &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h3><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><ul>
<li>下载: <code>npm install url-loader --save-dev</code><ul>
<li>如果是node5.0后的版本，需要安装: <code>npm install file-loader --save-dev</code></li>
</ul>
</li>
<li>作用: 可以把css中url(./xx.jpg)里的图片转换为base64形式。</li>
<li><p><em>注意: 使用用时，图片对应的css,要被相应的loader进行处理</em></p>
</li>
<li><p>使用: 要配合进行css处理的loader进行处理,专门用来处理css引用的图片！</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>:&#123;</div><div class="line">  <span class="attr">loaders</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">loader</span>:<span class="string">'style-loader!css-loader'</span>,</div><div class="line">        <span class="attr">test</span>:<span class="regexp">/\.css$/</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="comment">// 这个loader 使用用时，图片对应的css,要被相应的loader进行处理</span></div><div class="line">        <span class="comment">// 大图片不希望转换为base64</span></div><div class="line">        <span class="comment">// [name] 表示使用，每个名字都不一样</span></div><div class="line">        <span class="comment">// [ext] 表示原文件的后缀</span></div><div class="line">        loader:<span class="string">'url-loader?limit=13&amp;name=./img/[name].[ext]'</span>,</div><div class="line">        <span class="comment">// limit 单位是字节</span></div><div class="line">        <span class="comment">// 1 byte = 8bit</span></div><div class="line">        <span class="comment">// 1kb = 1024</span></div><div class="line">        <span class="comment">// 1m  = 1024kb</span></div><div class="line">        <span class="comment">// name 如果写成路径的形式，还会生成相应路径!</span></div><div class="line">        test:<span class="regexp">/\.(jpeg|jpg)$/</span></div><div class="line">      &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="做语法转换"><a href="#做语法转换" class="headerlink" title="做语法转换"></a>做语法转换</h3><p>babel</p>
<ul>
<li>es6-&gt; es5</li>
<li>jsx(react)语法-&gt;es6</li>
<li>… -&gt;es5</li>
</ul>
<h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><ul>
<li><code>npm install babel-loader --save-dev</code><ul>
<li>还需要安装babel-core</li>
</ul>
</li>
<li>作用:语法转换<ul>
<li>es6(es2015)-&gt;es5 : 安装: <code>npm install babel-preset-es2015</code></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">      <span class="attr">loaders</span>: [</div><div class="line">        &#123;</div><div class="line">          <span class="attr">test</span>:<span class="regexp">/\.js$/</span>,</div><div class="line">          <span class="attr">loader</span>:<span class="string">'babel-loader'</span>,</div><div class="line">          <span class="attr">query</span>:&#123;</div><div class="line"></div><div class="line">            <span class="comment">// es2015 对应 npm包是 babel-preset-es2015</span></div><div class="line">            <span class="comment">// </span></div><div class="line">            presets:[</div><div class="line">            <span class="string">'es2015'</span>,</div><div class="line">            <span class="comment">// 'react'  react对应的npm 包是 babel-preset-react</span></div><div class="line">            ] </div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h3><ul>
<li>A:<code>webpack -p</code> 加上-p参数就可以压缩代码</li>
<li>B: 使用压缩插件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plugins:[</div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()</div><div class="line">]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><ul>
<li>需要安装: <code>npm install webpack -save-dev</code></li>
<li>希望打包时，能够将第三方的库或者框架，与我们自己的代码分开打包</li>
<li>需要使用插件 </li>
<li>分离打包的目的，是为了让浏览器可以缓存第三方的库或者框架。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 插件</span></div><div class="line">  plugins:[</div><div class="line">   <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(</div><div class="line">    <span class="comment">// 第一个参数是entry的一个属性</span></div><div class="line">    <span class="comment">// 第二个参数是打包后的文件名</span></div><div class="line">    <span class="comment">// 打包后的js文件里包含,vendeor001指向的所有文件</span></div><div class="line">    <span class="string">'vendor001'</span>,<span class="string">'vender.js'</span></div><div class="line">    )</div><div class="line">  ]</div></pre></td></tr></table></figure>
<p>### </p>
<hr>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul>
<li>普通函数中的this: // <em>取决于调用者</em></li>
<li>箭头函数中的this: // <em>取决外围代码作用域中this的指向</em></li>
</ul>
<hr>
<h2 id="–watch参数"><a href="#–watch参数" class="headerlink" title="–watch参数"></a>–watch参数</h2><ul>
<li>在执行webpack命令时，可以加上–watch参数</li>
<li><code>webpack --watch</code> 会自动监视文件变化重新打包!</li>
</ul>
<h2 id="webpack-插件"><a href="#webpack-插件" class="headerlink" title="webpack 插件"></a>webpack 插件</h2><h3 id="自动打开浏览器插件-open-browser-webpack-plugin"><a href="#自动打开浏览器插件-open-browser-webpack-plugin" class="headerlink" title="自动打开浏览器插件(open-browser-webpack-plugin)"></a>自动打开浏览器插件(open-browser-webpack-plugin)</h3><ul>
<li><a href="https://github.com/baldore/open-browser-webpack-plugin" target="_blank" rel="external">github地址</a></li>
</ul>
<h3 id="创建index-html插件-html-webpack-plugin"><a href="#创建index-html插件-html-webpack-plugin" class="headerlink" title="创建index.html插件(html-webpack-plugin)"></a>创建index.html插件(html-webpack-plugin)</h3><ul>
<li><a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="external">github地址</a></li>
</ul>
<h3 id="删除目录插件-clean-webpack-plugin"><a href="#删除目录插件-clean-webpack-plugin" class="headerlink" title="删除目录插件(clean-webpack-plugin)"></a>删除目录插件(clean-webpack-plugin)</h3><ul>
<li><a href="https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="external">github地址</a></li>
</ul>
<h3 id="拷贝文件插件-copy-webpack-plugin"><a href="#拷贝文件插件-copy-webpack-plugin" class="headerlink" title="拷贝文件插件(copy-webpack-plugin)"></a>拷贝文件插件(copy-webpack-plugin)</h3><ul>
<li><a href="https://github.com/kevlened/copy-webpack-plugin" target="_blank" rel="external">github地址</a></li>
</ul>
<h2 id="开发时"><a href="#开发时" class="headerlink" title="开发时"></a>开发时</h2><ul>
<li>项目目录的src目录（在这个目录里做开发）<ul>
<li>这个目录可以称之为 [开发环境]</li>
</ul>
</li>
<li>项目目录的dist目录(最终代码生成到这生成)<ul>
<li>这个目录可以称之为 [生产环境]</li>
</ul>
</li>
</ul>
<h2 id="react-vue"><a href="#react-vue" class="headerlink" title="react,vue"></a>react,vue</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-移动app开发框架及工具" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/18/移动app开发框架及工具/" class="article-date">
  	<time datetime="2016-05-18T13:53:21.000Z" itemprop="datePublished">2016-05-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/18/移动app开发框架及工具/">
        app开发框架及工具使用
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关于反馈"><a href="#关于反馈" class="headerlink" title="关于反馈"></a>关于反馈</h2><p>//vue<br>// ng-app,init controller model, show hide if repeat switch….</p>
<p>// 75: // </p>
<p>移动端，移动Web,// 运行与移动浏览器中的一个网站;//<br>移动App,是一个软件(qq,wp)</p>
<h2 id="1-混合App-ionic"><a href="#1-混合App-ionic" class="headerlink" title="1.混合App(ionic)"></a>1.混合App(ionic)</h2><p>  有哪些技术可以开发手机软件</p>
<ul>
<li>java ,c++ // 原生开发</li>
</ul>
<h3 id="1-1什么是混合App-不同的技术混合开发的app"><a href="#1-1什么是混合App-不同的技术混合开发的app" class="headerlink" title="1.1什么是混合App(不同的技术混合开发的app)"></a>1.1什么是混合App(不同的技术混合开发的app)</h3><ul>
<li>application（应用）</li>
<li>用web前端的知识开发出来app的方式就叫做混合app开发</li>
<li>使用原生语言以及web语言一同开发的手机app.</li>
<li>WebView,可以类比成iframe</li>
</ul>
<h3 id="1-2为什么学习混合App"><a href="#1-2为什么学习混合App" class="headerlink" title="1.2为什么学习混合App"></a>1.2为什么学习混合App</h3><ul>
<li>双11。</li>
<li>java(1) 10k, oc(1) 10k</li>
<li>前端:10k</li>
<li>混合app,开发一次. 通过工具生成各个平台的安装，apk</li>
<li>钱: </li>
<li>回归本质 </li>
<li>有移动开发经验的开发人员比普通的web前端开发人员工资要高出一大截。</li>
<li>一个前端就可以做其他程序员的事情</li>
</ul>
<h3 id="1-3混合开发的目标是什么？"><a href="#1-3混合开发的目标是什么？" class="headerlink" title="1.3混合开发的目标是什么？"></a>1.3混合开发的目标是什么？</h3><ul>
<li>我们用学过的前端知识可以开发出一个可以安装在手机里面的app。</li>
<li>达到这一步就可以了,ionic除了配置环境之外，没有太多的东西。</li>
</ul>
<h3 id="1-4混合App开发部分课程要讲什么东西？"><a href="#1-4混合App开发部分课程要讲什么东西？" class="headerlink" title="1.4混合App开发部分课程要讲什么东西？"></a>1.4混合App开发部分课程要讲什么东西？</h3><ul>
<li>混合App开发所依赖的环境搭建(这个完成了，ionic就学了50%)</li>
<li>Angular中的一些其他知识点（路由,ngRoute是angular官网提供了,ui-route,第三方开发者提供)</li>
</ul>
<h3 id="1-5混合App课程会做什么项目"><a href="#1-5混合App课程会做什么项目" class="headerlink" title="1.5混合App课程会做什么项目?"></a>1.5混合App课程会做什么项目?</h3><ul>
<li>商城项目<br>+下面的截图就是用混合开发中Ionic框架方式开发的</li>
</ul>
<p><img src="ReadeImgs/jd1.png" alt="项目图片1"> <img src="ReadeImgs/jd2.png" alt="项目图片2"><br><img src="ReadeImgs/jd3.png" alt="项目图片3"></p>
<h2 id="2-混合App简介"><a href="#2-混合App简介" class="headerlink" title="2.混合App简介"></a>2.混合App简介</h2><ul>
<li>ionic</li>
</ul>
<h3 id="2-1-现在app开发方类型有几种？"><a href="#2-1-现在app开发方类型有几种？" class="headerlink" title="2.1.现在app开发方类型有几种？"></a>2.1.现在app开发方类型有几种？</h3><ul>
<li><p>混合app,原生app: android-java ios-objective-c:swift</p>
</li>
<li><p>WebApp:就是在浏览器中运行的web应用(比如用angular做的单页应用就叫做webapp,页面功能复杂了，不再是纯粹的展示文字，图片)</p>
</li>
<li><p>NativeApp:用java(android)或Object-C(ios),C# 开发window phone(软件太少)等原生语言开发的应用</p>
</li>
<li><p>HybridApp:就是外面是原生的壳，里面是webapp应用，兼具2者的优势</p>
<ul>
<li>apk是安卓安装包的后缀</li>
</ul>
</li>
</ul>
<h3 id="2-2-三种开发类型的原理和对比"><a href="#2-2-三种开发类型的原理和对比" class="headerlink" title="2.2.三种开发类型的原理和对比"></a>2.2.三种开发类型的原理和对比</h3><ul>
<li>截几张图</li>
</ul>
<p><img src="ReadeImgs/web,hybir,native.png" alt="三种开发类型优劣对比"></p>
<h3 id="2-3企业如何选择用那种方式开发产品呢？"><a href="#2-3企业如何选择用那种方式开发产品呢？" class="headerlink" title="2.3企业如何选择用那种方式开发产品呢？"></a>2.3企业如何选择用那种方式开发产品呢？</h3><blockquote>
<p>企业要根据自身的特点进行app开发方式的选择，不要为了混合而混合。<br>混合app的开发方式是未来的主流趋势。</p>
</blockquote>
<h2 id="3-流行开发框架介绍"><a href="#3-流行开发框架介绍" class="headerlink" title="3.流行开发框架介绍"></a>3.流行开发框架介绍</h2><h3 id="3-1-移动端开发有哪些框架呢？"><a href="#3-1-移动端开发有哪些框架呢？" class="headerlink" title="3.1.移动端开发有哪些框架呢？"></a>3.1.移动端开发有哪些框架呢？</h3><ul>
<li>Ionic –,   // 重装系统 。</li>
<li></li>
<li><p>Html5+</p>
</li>
<li><p>AppCan</p>
</li>
<li><p>Framework7</p>
</li>
<li><p>Jquery Mobile //</p>
</li>
<li><p>React Native</p>
<ul>
<li>用js写出原生的app。</li>
</ul>
</li>
<li><p>weex 阿里出的</p>
</li>
</ul>
<h3 id="3-2HTML5"><a href="#3-2HTML5" class="headerlink" title="3.2HTML5+"></a>3.2HTML5+</h3><h4 id="3-2-1首先要认识Html5-联盟是什么？"><a href="#3-2-1首先要认识Html5-联盟是什么？" class="headerlink" title="3.2.1首先要认识Html5+联盟是什么？"></a>3.2.1首先要认识Html5+联盟是什么？</h4><blockquote>
<p>HTML5中国产业联盟，简称“HTML5+联盟”，是为了更好的推进HTML5的商用、更好的为HTML5开发者服务而由产 业链主流厂商共同组成的一个联盟。<br>联盟致力于整合产业链资源，建立围绕HTML5开发者的生态系统，通过产业链共同为HTMLl5开发者服务。<br>W3C中国是联盟的指导单位。<br>CSDN 和 DCloud 是联盟的秘书处单位。</p>
</blockquote>
<h4 id="3-2-2-Dcloud官网"><a href="#3-2-2-Dcloud官网" class="headerlink" title="3.2.2.Dcloud官网"></a>3.2.2.Dcloud官网</h4><ul>
<li><a href="http://www.dcloud.io/" target="_blank" rel="external">官网地址</a></li>
<li><a href="http://docs.emmet.io/cheat-sheet/" target="_blank" rel="external">Emmet语法</a></li>
<li>Dclout4个核心产品<br><img src="ReadeImgs/html5+01.png" alt="Dclout4个核心产品"><ul>
<li>HBuilder：是一款web开发工具。它能大幅提升开发效率，对程序员也设计了更人文关怀的UI，它包括最全面的语法库和浏览器兼容性数据。到现在 已经有两年的时间了，到现在大概有几十万的开发者在使用。</li>
<li>5+Runtime：是一个H5的增强引擎。这是一个可以去调用H5的能力和原生操作系统的产 品。  </li>
<li>MUI框架：是高性能的前端框架，可用开发高性能App，也是目前最接近原生App效果的框架，可以有效解决HTML5原生开发中遇到的部分问题，同 时体积也小。</li>
<li>流应用：会让用户感觉一点开就可以用，这也是颠覆现有的应用方式的主要因素，给最终用户去使用应用有更好的体验。<ul>
<li>如果手机上安装用360手机市场的话，html5+开发的移动扫一下二维码,只需要一点点流量就能够使用了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-3-Html5-的优点"><a href="#3-2-3-Html5-的优点" class="headerlink" title="3.2.3.Html5+的优点"></a>3.2.3.Html5+的优点</h4><ul>
<li>提供了一个自定制的IDE工具，支持非常好，轻量级，甚至不需要安装直接解压缩就可以使用</li>
<li>开发出来的app的性能很好，用户体验很高</li>
<li>丰富的api支持，号称有40万+</li>
</ul>
<h4 id="3-2-4-Html5-的缺点"><a href="#3-2-4-Html5-的缺点" class="headerlink" title="3.2.4.Html5+的缺点"></a>3.2.4.Html5+的缺点</h4><ul>
<li>打包比较麻烦，需要上传源码，有些公司可以不希望公开源码</li>
<li>从新学习样式</li>
</ul>
<p>是国产的(爱国)</p>
<h4 id="3-2-5-现在那些公司在用Html5"><a href="#3-2-5-现在那些公司在用Html5" class="headerlink" title="3.2.5.现在那些公司在用Html5+?"></a>3.2.5.现在那些公司在用Html5+?</h4><p><a href="ReadeImgs/html5+poduction.png">html5+开发的产品</a></p>
<h3 id="3-3-Ionic介绍"><a href="#3-3-Ionic介绍" class="headerlink" title="3.3.Ionic介绍"></a>3.3.Ionic介绍</h3><h4 id="3-3-1-官网地址"><a href="#3-3-1-官网地址" class="headerlink" title="3.3.1.官网地址"></a>3.3.1.官网地址</h4><ul>
<li><a href="http://ionicframework.com/" target="_blank" rel="external">Ionic官网</a></li>
<li><a href="http://www.ionic.wang/" target="_blank" rel="external">Ionic中文网</a></li>
</ul>
<h4 id="3-3-2-首先要认识Ionic框架？"><a href="#3-3-2-首先要认识Ionic框架？" class="headerlink" title="3.3.2.首先要认识Ionic框架？"></a>3.3.2.首先要认识Ionic框架？</h4><blockquote>
<p>IONIC 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，<br>它提供了很多 UI 组件来帮助开发者开发强大的应用。 它使用 JavaScript MVVM 框架<br>和 AngularJS 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共<br>同选择。Ionic是一个专注于用WEB开发技术，基于HTML5创建类似于手机平台原生应用的<br>一个开发框架。Ionic框架的目的是从 web的角度开发手机应用，基于PhoneGap的编译平<br>台，可以实现编译成各个平台的应用程序。</p>
</blockquote>
<h4 id="3-3-3-ionic框架构成"><a href="#3-3-3-ionic框架构成" class="headerlink" title="3.3.3.ionic框架构成"></a>3.3.3.ionic框架构成</h4><ul>
<li>CSS框架 - 提供原生 App 质感的 CSS 样式模拟。 ionic 这部分的实现使用了 ionicons 图标样式库。</li>
<li>JavaScript框架 - 提供移动 Web 应用开发框架。ionic 基于 AngularJS 基础框架开发，遵循 AngularJS 的框架约束；此外 ionic 使用 AngularJS UI Router 实现前端路由。</li>
<li>命令行/CLI - 命令行工具集用来简化应用的开发、构造和仿真运行。ionic 命令行工具使用了 Cordova，依赖于平台 SDK（Android &amp; iOS）实现将移动 Web 项目打包成原生 App。</li>
</ul>
<h4 id="3-3-4Ionic特点"><a href="#3-3-4Ionic特点" class="headerlink" title="3.3.4Ionic特点"></a>3.3.4Ionic特点</h4><ul>
<li>基于Angular语法，简单易学。</li>
<li>是一个轻量级框架。性能优越，运行速度快。</li>
<li>完美的融合下一代移动框架，支持 Angularjs 的特性， MVC ，代码易维护。</li>
<li>提供了漂亮的设计，通过SASS构建应用程序，它提供了很多UI组件来帮助开发者开发强大的应用。</li>
<li>专注原生，让你看不出混合应用和原生的区别</li>
<li>提供了强大的命令行工具。</li>
</ul>
<h4 id="3-3-5-ionic开发注意点有哪些？"><a href="#3-3-5-ionic开发注意点有哪些？" class="headerlink" title="3.3.5.ionic开发注意点有哪些？"></a>3.3.5.ionic开发注意点有哪些？</h4><blockquote>
<p>由于 ionic 使用了 HTML5 和 CSS3 的一些新规范，所以要求 iOS7+ / Android4.1+。<br>在低于这些版本的手机上使用 ionic 开发的应用，有时会发生莫名其妙的问题。</p>
</blockquote>
<h4 id="3-3-6-现在那些公司再用ionic开发？"><a href="#3-3-6-现在那些公司再用ionic开发？" class="headerlink" title="3.3.6.现在那些公司再用ionic开发？"></a>3.3.6.现在那些公司再用ionic开发？</h4><ul>
<li><a href="http://www.phonegap100.com/app.html" target="_blank" rel="external">查看ionic开发的app的地址</a></li>
</ul>
<h3 id="3-4-React-Native-介绍"><a href="#3-4-React-Native-介绍" class="headerlink" title="3.4 React Native 介绍"></a>3.4 React Native 介绍</h3><h4 id="3-4-1-官网地址"><a href="#3-4-1-官网地址" class="headerlink" title="3.4.1 官网地址"></a>3.4.1 官网地址</h4><ul>
<li><a href="https://facebook.github.io/react-native/" target="_blank" rel="external">官网</a></li>
<li><a href="http://react-native.cn/" target="_blank" rel="external">中文网</a></li>
</ul>
<h4 id="3-4-2-React-native原理图"><a href="#3-4-2-React-native原理图" class="headerlink" title="3.4.2.React native原理图"></a>3.4.2.React native原理图</h4><ul>
<li><img src="RN原理图.png" alt="原理图"></li>
</ul>
<h4 id="3-4-3-React-Native核心实现是什么？"><a href="#3-4-3-React-Native核心实现是什么？" class="headerlink" title="3.4.3.React Native核心实现是什么？"></a>3.4.3.React Native核心实现是什么？</h4><ul>
<li><p>React Native里面没有webview，这货不是Hybrid app，里面执行JS是用的 JavascriptCore。</p>
</li>
<li><p>把Native code十来个最基本核心的类（RCTDeviceEventEmitter、RCTRenderingPerf等）、或组件（RCTView、RCTTextField、RCTTextView、RCTModalFullscreenView等）封装成二十来个基本组件（Popover、Listview等）</p>
</li>
<li><p>实现了一套类似css的子集，用来解决样式问题，相当复杂和强大，靠这个才能将Native的核心组件组成JS层的基本组件再组成业务端的业务组件</p>
</li>
<li><p>在React Native中，写JS的工程师解决的是「将基本组件拼装成可用的React组件」的问题，写Native Code的工程师解决的是「提供核心组件，提供足够的扩展性、灵活性和性能」的问题。</p>
</li>
</ul>
<h4 id="3-4-4-React-Native的优点有哪些？"><a href="#3-4-4-React-Native的优点有哪些？" class="headerlink" title="3.4.4.React Native的优点有哪些？"></a>3.4.4.React Native的优点有哪些？</h4><ul>
<li>不用Webview，彻底摆脱了Webview让人不爽的交互和性能问题。</li>
<li>有较强的扩展性，这是因为Native端提供的是基本控件，JS可以自由组合使用。</li>
<li>可以直接使用Native原生的「牛逼」动画。</li>
<li>可以通过更新远端JS，直接更新app。</li>
</ul>
<h4 id="3-4-5-现在那些公司在用React-Native"><a href="#3-4-5-现在那些公司在用React-Native" class="headerlink" title="3.4.5.现在那些公司在用React Native"></a>3.4.5.现在那些公司在用React Native</h4><ul>
<li><a href="https://facebook.github.io/react-native/showcase.html" target="_blank" rel="external">案例地址</a></li>
<li><img src="ReadeImgs/RN案例.png" alt="案例图片"></li>
</ul>
<h3 id="3-5-Jquery-Mobile介绍"><a href="#3-5-Jquery-Mobile介绍" class="headerlink" title="3.5.Jquery Mobile介绍"></a>3.5.Jquery Mobile介绍</h3><h4 id="3-5-1-官网地址"><a href="#3-5-1-官网地址" class="headerlink" title="3.5.1.官网地址"></a>3.5.1.官网地址</h4><ul>
<li>官网地址 <a href="http://jquerymobile.com/" target="_blank" rel="external">http://jquerymobile.com/</a></li>
<li>中文网地址 <a href="http://jquerymobile.weebly.com/jquerymobile3245220214.html" target="_blank" rel="external">http://jquerymobile.weebly.com/jquerymobile3245220214.html</a></li>
<li>APi学习地址 <a href="http://www.w3school.com.cn/jquerymobile/index.asp" target="_blank" rel="external">http://www.w3school.com.cn/jquerymobile/index.asp</a></li>
</ul>
<h4 id="3-5-2-Jquery-Mobile是做什么的？"><a href="#3-5-2-Jquery-Mobile是做什么的？" class="headerlink" title="3.5.2.Jquery Mobile是做什么的？"></a>3.5.2.Jquery Mobile是做什么的？</h4><ul>
<li>jQuery Mobile 是一个为触控优化的web框架，用于创建移动 web 应用程序。</li>
<li>jQuery 适用于所有流行的智能手机和平板电脑</li>
<li>jQuery Mobile 构建于 jQuery 库之上，这使其更易学习，如果您通晓 jQuery 的话。</li>
<li>它使用 HTML5、CSS3、JavaScript 和 AJAX 通过尽可能少的代码来完成对页面的布局。</li>
</ul>
<h3 id="3-6-AppCan介绍-国产"><a href="#3-6-AppCan介绍-国产" class="headerlink" title="3.6.AppCan介绍(国产)"></a>3.6.AppCan介绍(国产)</h3><h4 id="3-6-1官网地址"><a href="#3-6-1官网地址" class="headerlink" title="3.6.1官网地址"></a>3.6.1官网地址</h4><ul>
<li>官网地址 <a href="http://www.appcan.cn/" target="_blank" rel="external">http://www.appcan.cn/</a></li>
</ul>
<h4 id="3-6-2-首先来认识AppCan是什么？"><a href="#3-6-2-首先来认识AppCan是什么？" class="headerlink" title="3.6.2.首先来认识AppCan是什么？"></a>3.6.2.首先来认识AppCan是什么？</h4><blockquote>
<p>AppCan.cn开发平台是基于HTML5技术的跨平台移动应用快速开发一体化解决方案。开发者利用HTML5+CSS3+JavaScript技术可 以快速地开发与本地应用体验相媲美的移动应用。AppCan.cn平台提供了UI快速开发框架、本地功能调用API接口、应用打包系统、IDE集成开发环 境和本地应用调试模拟器，预置数百套界面模板和数十种应用插件，提供多套应用模板。完善的框架接口，人性化的开发环境，丰富的开发资源，强大的服务支持， 使开发者可以快速迈入移动开发领域。</p>
</blockquote>
<h4 id="3-6-3-谁在用AppCan"><a href="#3-6-3-谁在用AppCan" class="headerlink" title="3.6.3.谁在用AppCan?"></a>3.6.3.谁在用AppCan?</h4><ul>
<li>项目演示 <a href="http://www.appcan.cn/appshow/index.html" target="_blank" rel="external">http://www.appcan.cn/appshow/index.html</a></li>
</ul>
<h2 id="4-学习方法介绍"><a href="#4-学习方法介绍" class="headerlink" title="4.学习方法介绍"></a>4.学习方法介绍</h2><h3 id="4-1思想态度"><a href="#4-1思想态度" class="headerlink" title="4.1思想态度"></a>4.1思想态度</h3><ul>
<li>前端没有那么简单,但也不难 ,js,html5,css3</li>
<li>没有人能平白无故的得到成功</li>
<li>积极努力</li>
<li>利用一切时间</li>
<li>再加上一些好的学习方法</li>
</ul>
<h3 id="4-2-价值观"><a href="#4-2-价值观" class="headerlink" title="4.2.价值观"></a>4.2.价值观</h3><ul>
<li>脚踏实地，厚积薄发</li>
<li>懂得取舍，莫扣细节</li>
</ul>
<h3 id="4-3-新技术学习的本质？"><a href="#4-3-新技术学习的本质？" class="headerlink" title="4.3.新技术学习的本质？"></a>4.3.新技术学习的本质？</h3><ul>
<li>一门新技术无非就是一些新概念的提出，伴随着一套完整的规则约定。</li>
</ul>
<h3 id="4-4-如何学习？"><a href="#4-4-如何学习？" class="headerlink" title="4.4.如何学习？"></a>4.4.如何学习？</h3><p>  1、官网看docs<br>  2、官网看不懂找相应的中文网<br>  3、根据快速开始的指引或者从github上找一些快速开始的kit学习，勤练习，至少要把大部分的api都搞过一次。<br>  4、加qq群，微信群<br>  5、搜博客和视频</p>
<h3 id="4-5-每天都应该上的几个网站？"><a href="#4-5-每天都应该上的几个网站？" class="headerlink" title="4.5.每天都应该上的几个网站？"></a>4.5.每天都应该上的几个网站？</h3><ul>
<li>OSChina</li>
<li>InfoQ</li>
<li>CSDN</li>
<li>Cnode社区</li>
</ul>
<h2 id="5-ionic框架主要技术介绍"><a href="#5-ionic框架主要技术介绍" class="headerlink" title="5.ionic框架主要技术介绍"></a>5.ionic框架主要技术介绍</h2><h3 id="5-1-Cordova介绍"><a href="#5-1-Cordova介绍" class="headerlink" title="5.1.Cordova介绍"></a>5.1.Cordova介绍</h3><h4 id="5-1-1官网地址"><a href="#5-1-1官网地址" class="headerlink" title="5.1.1官网地址"></a>5.1.1官网地址</h4><ul>
<li><a href="https://cordova.apache.org/" target="_blank" rel="external">官网地址</a></li>
</ul>
<h4 id="5-1-2-Cordova是什么？"><a href="#5-1-2-Cordova是什么？" class="headerlink" title="5.1.2.Cordova是什么？"></a>5.1.2.Cordova是什么？</h4><ul>
<li><p>Cordova提供了一组设备相关的API，通过这组API，移动应用能够以JavaScript访问原生的设备功能，如摄像头、麦克风等。</p>
</li>
<li><p>Cordova支持如下移动操作系统：iOS, Android,ubuntu phone os, Blackberry, Windows Phone, Palm WebOS, Bada 和 Symbian。</p>
</li>
</ul>
<h4 id="5-1-3和phonegap的关系？"><a href="#5-1-3和phonegap的关系？" class="headerlink" title="5.1.3和phonegap的关系？"></a>5.1.3和phonegap的关系？</h4><ul>
<li>Cordova是贡献给Apache后的开源项目，是从PhoneGap中抽出的核心代码，目前(PhoneGap和Apache Cordova之间的)唯一区别是下载的包的名字，这会持续一段时间。</li>
</ul>
<h3 id="5-2-Ng-cordova介绍"><a href="#5-2-Ng-cordova介绍" class="headerlink" title="5.2.Ng-cordova介绍"></a>5.2.Ng-cordova介绍</h3><h4 id="5-2-1-官网地址"><a href="#5-2-1-官网地址" class="headerlink" title="5.2.1.官网地址"></a>5.2.1.官网地址</h4><ul>
<li><a href="http://ngcordova.com/" target="_blank" rel="external">官网地址</a></li>
</ul>
<h4 id="5-2-2-Ng-cordova是什么？"><a href="#5-2-2-Ng-cordova是什么？" class="headerlink" title="5.2.2.Ng-cordova是什么？"></a>5.2.2.Ng-cordova是什么？</h4><ul>
<li>ngCordova是在Cordova Api基础上封装的一系列开源的AngularJs服务和指令扩展，让开发者可以方便的在HybridApp开发中调用设备能力，即可以在AngularJs代码中访问设备能力Api。</li>
<li>在cordova插件的sucess和error js回调方法中，是无法使用 angularjs的$scope对象和注入的方法的，只能访问全局的方法和变量，这样会导致很多麻烦，必须使用传统的js方法写很多难看的代码。使用 ngCordova可以解决这个问题。</li>
</ul>
<h3 id="5-3-Angular介绍"><a href="#5-3-Angular介绍" class="headerlink" title="5.3.Angular介绍"></a>5.3.Angular介绍</h3><ul>
<li>此处省略100字</li>
</ul>
<h4 id="5-3-4-Angular适用于哪些场景？"><a href="#5-3-4-Angular适用于哪些场景？" class="headerlink" title="5.3.4.Angular适用于哪些场景？"></a>5.3.4.Angular适用于哪些场景？</h4><p>  1、单页面应用程序<br>  2、Angular更适合于CRUD的管理系统开发。<br>  3、也非常适合模块化，分层化，数据绑定<br>  4、hybrid开发神器</p>
<h4 id="5-3-5-Angular不适用于哪些场景？"><a href="#5-3-5-Angular不适用于哪些场景？" class="headerlink" title="5.3.5.Angular不适用于哪些场景？"></a>5.3.5.Angular不适用于哪些场景？</h4><p>  1、内容网站，需要SEO的。(SEO目前也有了prerender解决方案)<br>  2、交互频繁的，如游戏之类交互体验网站。（单页面应用程序）<br>  3、太过于简单的页面。（因为要考虑mvc,注入等，就会笨重）</p>
<h3 id="5-4-Angular-2"><a href="#5-4-Angular-2" class="headerlink" title="5.4.Angular 2"></a>5.4.Angular 2</h3><h4 id="组件化，移动化"><a href="#组件化，移动化" class="headerlink" title="组件化，移动化"></a>组件化，移动化</h4><h3 id="5-5-ES6介绍"><a href="#5-5-ES6介绍" class="headerlink" title="5.5.ES6介绍"></a>5.5.ES6介绍</h3><h4 id="5-5-1-ES6历史"><a href="#5-5-1-ES6历史" class="headerlink" title="5.5.1.ES6历史"></a>5.5.1.ES6历史</h4><blockquote>
<p>1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成 为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是ECMAScript 1.0版。</p>
</blockquote>
<h4 id="5-5-2-ES6是什么？"><a href="#5-5-2-ES6是什么？" class="headerlink" title="5.5.2.ES6是什么？"></a>5.5.2.ES6是什么？</h4><ul>
<li>ECMA-262 的第六次变更，所有以前按照惯例称为es6，ES2015</li>
<li>ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。</li>
<li>2015年6月，ECMAScript 6正式通过，成为国际标准。</li>
<li>Node.js是JavaScript语言的服务器运行环境。它们对ES6的支持度，比浏览器更高。通过它们，可以体验更多ES6的特性。</li>
<li>这个标准的牛逼之处就在于会逐步统一前端，因为新增加的module,异步编程，Generator函数这些东西在angular中和node中都有很好的实现了。</li>
</ul>
<h3 id="5-5-3-ES6学习地址"><a href="#5-5-3-ES6学习地址" class="headerlink" title="5.5.3.ES6学习地址"></a>5.5.3.ES6学习地址</h3><ul>
<li><a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="external">ECMAScript6学习网址</a></li>
</ul>
<p><a href="http://services.gradle.org/distributions" target="_blank" rel="external">http://services.gradle.org/distributions</a></p>
<p>流应用<br><a href="http://www.dcloud.io/streamapp.html" target="_blank" rel="external">http://www.dcloud.io/streamapp.html</a></p>
<p>[TOC]</p>
<p><style> .toc{position:fixed;z-index:999;left:0;top:0px;bottom:5px;padding:15px  0 0 0;border-top-right-radius:5px;border-bottom-right-radius:5px;width:250px;overflow:auto;background-color:#fff;border:1px solid #ccc;}.tocul{position:absolute;hgieht:100%;overflow:auto} .toc a{color:#333 !important;font-weight:600}</style></p>
<script>function myq(arg){return document.querySelector(arg);}</script>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-app开发环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/11/app开发环境搭建/" class="article-date">
  	<time datetime="2016-05-11T13:53:21.000Z" itemprop="datePublished">2016-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/11/app开发环境搭建/">
        app开发环境搭建1
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="jdk-运行java语言需要的。"><a href="#jdk-运行java语言需要的。" class="headerlink" title="jdk - 运行java语言需要的。"></a>jdk - 运行java语言需要的。</h2><h2 id="sdk-android开发需要。"><a href="#sdk-android开发需要。" class="headerlink" title="sdk - android开发需要。"></a>sdk - android开发需要。</h2><ul>
<li>android studio,除了能写代码之外，还提供sdk</li>
</ul>
<h2 id="python-2-7-x"><a href="#python-2-7-x" class="headerlink" title="python-2.7.x"></a>python-2.7.x</h2><ul>
<li>react-native需要用的。</li>
</ul>
<h2 id="visual-studio-2015"><a href="#visual-studio-2015" class="headerlink" title="visual studio 2015"></a>visual studio 2015</h2><ul>
<li>c++ 环境</li>
<li>如果安装过这个的其他版本，就先不安装。</li>
<li>时间,耗时最长: 2小时候, 40左右。</li>
<li>网络,不要联网(安装时)（更新）<ul>
<li>联网时会更新，特别耗时。</li>
</ul>
</li>
<li>c盘有多大,(选择安装到其他盘，最终还是大部安装到C盘)</li>
<li>c++ 大概11G</li>
<li>如果磁盘不够。</li>
<li>分区工具: ‘<a href="http://www.disktool.cn/jiaocheng/resize-partition.html" target="_blank" rel="external">http://www.disktool.cn/jiaocheng/resize-partition.html</a>‘</li>
</ul>
<h2 id="npm-install-jquery-–save"><a href="#npm-install-jquery-–save" class="headerlink" title="npm install jquery –save"></a>npm install jquery –save</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-app开发环境搭建2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/11/app开发环境搭建2/" class="article-date">
  	<time datetime="2016-05-11T13:53:21.000Z" itemprop="datePublished">2016-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/11/app开发环境搭建2/">
        app开发环境搭建2
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-安装jdk"><a href="#1-安装jdk" class="headerlink" title="1.安装jdk"></a>1.安装jdk</h2><h2 id="2-配置jdk的环境变量"><a href="#2-配置jdk的环境变量" class="headerlink" title="2.配置jdk的环境变量"></a>2.配置jdk的环境变量</h2><h2 id="3-安装python"><a href="#3-安装python" class="headerlink" title="3.安装python"></a>3.安装python</h2><h2 id="4-配置python的环境变量"><a href="#4-配置python的环境变量" class="headerlink" title="4.配置python的环境变量"></a>4.配置python的环境变量</h2><h2 id="5-安装ionic-和-cordova"><a href="#5-安装ionic-和-cordova" class="headerlink" title="5.安装ionic 和 cordova"></a>5.安装ionic 和 cordova</h2><ul>
<li><code>npm install -g cordova</code></li>
<li><code>npm install -g ionic</code><blockquote>
<p>如果一次下载不成功，多试几次。</p>
</blockquote>
</li>
</ul>
<h2 id="6-安装Android-studio-并配置sdk的环境变量"><a href="#6-安装Android-studio-并配置sdk的环境变量" class="headerlink" title="6. 安装Android studio 并配置sdk的环境变量"></a>6. 安装Android studio 并配置sdk的环境变量</h2><ul>
<li>1.找到sdk的路径: C:\Users\isc\AppData\Local\Android\sdk</li>
<li><p>2.把1中的路径配置到环境变量中:</p>
<ul>
<li>变量名: <code>ANDROID_HOME</code></li>
<li>变量值: <code>C:\Users\isc\AppData\Local\Android\sdk</code></li>
</ul>
</li>
<li><p>3.在PATH中配置相应的值(追加):</p>
<ul>
<li><code>%ANDROID_HOME%\platform-tools</code></li>
<li><code>%ANDROID_HOME%\tools</code></li>
</ul>
</li>
<li>4.在命令行使用<code>adb</code>验证是否安装成功(输出一大托就成功了)</li>
</ul>
<h2 id="7-开始使用"><a href="#7-开始使用" class="headerlink" title="7. 开始使用"></a>7. 开始使用</h2><p><a href="http://ionicframework.com/getting-started/" target="_blank" rel="external">http://ionicframework.com/getting-started/</a></p>
<ul>
<li>7.1 得到基本的项目结构(命令只需要执行一次)<ul>
<li><code>ionic start &lt;项目名:不能是中文&gt;  &lt;项目模板&gt;</code></li>
<li>说明: &lt;项目模板&gt; 有3个值： blank, tabs, sidemenu</li>
<li>示例:<code>ionic start myApp tabs</code><ul>
<li>执行成功之后会生成myApp目录</li>
<li>执行的过程可以参照:others/截图/01.ionic_start_myapp_tabs.png</li>
</ul>
</li>
</ul>
</li>
<li>7.2 然后在myApp/www 目录下开发(就写html,css,js)</li>
<li>7.3 添加不同平台的源码（命令只需要执行一次）<ul>
<li><code>ionic platform add android</code> (那些第一次下载成功，以后都不用下载)</li>
<li>执行完这个命令后myApp目录会多个platforms目录，这个目录里有<br>个android目录，就对应android的源码。</li>
<li>执行过程参照:others/截图/02.ionc_platform_add_android.png</li>
</ul>
</li>
<li><p>7.4 编译生成apk</p>
<ul>
<li><code>ionic build android</code> // 会生成相应apk</li>
<li>执行过程参照:others/截图/03.ionic_build_android.png</li>
</ul>
</li>
<li><p>试错 kkisc   c# 做桌面应用程序</p>
</li>
</ul>
<h3 id="visual-studio"><a href="#visual-studio" class="headerlink" title="visual studio"></a>visual studio</h3><ul>
<li>可以先不安装，出现错误时就安装, C++</li>
</ul>
<blockquote>
<p>刚刚我们拷贝的目的:是为了代替使用npm命令安装</p>
</blockquote>
<p>// 可以改变npm的下载地址.<br>npm install -g ionic     –registry=地址</p>
<p>fastcapture注册码:<br>Name: ZRQX</p>
<p>Code: FOZRJILDQIYCHCIHSSQN</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-node06" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/17/node06/" class="article-date">
  	<time datetime="2016-04-17T12:24:22.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/node06/">
        node06
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>什么是协议？<br>  网络协议为计算机网络中进行数据交换而建立的规则、标准或约定的集合。<br>  例如，网络中一个微机用户和一个大型主机的操作员进行通信，由于这两个<br>  数据终端所用字符集不同，因此操作员所输入的命令彼此不认识。为了能进行通信，<br>  规定每个终端都要将各自字符集中的字符先变换为标准字符集的字符后，才进入网络传送，<br>  到达目的终端之后，再变换为该终端字符集的字符。当然，对于不相容终端，<br>  除了需变换字符集字符外还需转换其他特性，如显示格式、行长、行数、<br>  屏幕滚动方式等也需作相应的变换。</p>
<p>  网络协议是由三个要素组成：<br>  1.语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。<br>  2.语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。<br>  3.时序：时序是对事件发生顺序的详细说明。（也可称为“同步”）。</p>
</li>
</ul>
<h3 id="1-2-http协议"><a href="#1-2-http协议" class="headerlink" title="1.2 http协议"></a>1.2 http协议</h3><h3 id="1-3session-amp-cookie"><a href="#1-3session-amp-cookie" class="headerlink" title="1.3session&amp;cookie"></a>1.3session&amp;cookie</h3><h3 id="1-4-工具的使用"><a href="#1-4-工具的使用" class="headerlink" title="1.4 工具的使用"></a>1.4 工具的使用</h3><h3 id="通过-nodemon-实现-保存文件实时重启"><a href="#通过-nodemon-实现-保存文件实时重启" class="headerlink" title="通过 nodemon 实现 保存文件实时重启"></a>通过 nodemon 实现 保存文件实时重启</h3><ol>
<li>安装nodemon <code>npm install -g nodemon</code></li>
<li>基本使用 <code>nodemon server.js</code></li>
</ol>
<p>只要执行了上面的命令，那么当你修改了 server.js 那么nodemon会帮你自动重启 server</p>
<p>###2.1 使用npm命令执行代码<br>1.package.json里面配置scripts属性里面写npm的命令<br>2.npm的命令在控制台直接npm打印出来可以查看<br>3.npm命令后面接的是具体的命令，打npm命令调用具体的命令</p>
<p>###2.2编写node脚本<br>1.把js代码变成node脚本<br>在要执行的js文件当中加入下面这句话，是固定写法</p>
<p>#!/usr/bin/env node</p>
<p>2.package.json里面配置bin属性里面写命令,这个命令的名称是可以自定义的</p>
<p>3.必须打npm link这个命令，把当前包安装到全局去</p>
<p>###2.3通过命令调用脚本</p>
<h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><h3 id="使用-http-模块进行web开发"><a href="#使用-http-模块进行web开发" class="headerlink" title="使用 http 模块进行web开发"></a>使用 http 模块进行web开发</h3><ul>
<li>创建 HTTP 服务器</li>
</ul>
<p><code>http.createServer([requestListener])</code></p>
<ul>
<li><p>通过监听Event: ‘request’来进行<br>server.on(‘request’,(request,response) =&gt; {});</p>
</li>
<li><p>request、response对象<br>request对象，用于接收请求报文内的信息<br>response对象，用于返回响应报文内的信息</p>
</li>
<li><p>response.write()<br>write方法用于向响应体里写内容，用于向客户端发送信息，可以被多次使用</p>
</li>
<li><p>response.end()<br>在一次请求和响应过程当中，只要调用了  end 就不能再继续 write 了<br>就说明你是在一次请求和响应处理过程中已经结束了响应，但是又去 向客户端发送数据<br>这个时候就会报错</p>
</li>
<li><p>server.listen(port[, hostname][, backlog][, callback])<br>监听端口，执行这句，服务正式被启动使用<br>server.listen(3000,’127.0.0.1’,() =&gt; {<br>console.log(‘server is listening at port 3000’);<br>});</p>
</li>
</ul>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><ul>
<li>request.headers 请求头</li>
<li>request.method 请求方法</li>
<li>request.url 请求路径</li>
<li>request.httpVersion 请求HTTP协议版本</li>
</ul>
<h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><ul>
<li>res.writeHead(200,{‘Content-Type’: ‘text/html; charset=utf-8’});<br>设置响应报文头</li>
<li>res.write(‘<h1>hello world</h1>‘);</li>
<li>res.end();</li>
</ul>
<h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，<br>决定文件接收方将以什么形式、什么编码读取这个文</p>
<h3 id="通过-req-url和req-method的不同给出不同的响应"><a href="#通过-req-url和req-method的不同给出不同的响应" class="headerlink" title="通过 req.url和req.method的不同给出不同的响应"></a>通过 req.url和req.method的不同给出不同的响应</h3><p>  if (req.url == ‘/‘ &amp;&amp; req.method == ‘GET’) {<br>    res.writeHead(200, {<br>      ‘Content-Type’: ‘text/html; charset=utf-8’<br>    });<br>    res.write(‘</p><h1>首页</h1>‘);<br>    res.end();<br>  }<p></p>
<h3 id="request通过data事件和end事件来接收post的数据"><a href="#request通过data事件和end事件来接收post的数据" class="headerlink" title="request通过data事件和end事件来接收post的数据"></a>request通过data事件和end事件来接收post的数据</h3><p>let data = ‘’;<br>req.on(‘data’, (chunk) =&gt; {<br>      data += chunk;<br>});<br> req.on(‘end’, () =&gt; {<br>      console.log(data);<br>      res.writeHead(200, {<br>        ‘Content-Type’: ‘text/html; charset=utf-8’<br>      });<br>      res.write(‘</p><h1>收到数据了</h1>‘);<br>      res.end();<br> });<p></p>
<h3 id="通过-querystring解析post的数据"><a href="#通过-querystring解析post的数据" class="headerlink" title="通过 querystring解析post的数据"></a>通过 querystring解析post的数据</h3><p>querystring.parse(‘foo=bar&amp;baz=qux&amp;baz=quux&amp;corge’)<br>// returns { foo: ‘bar’, baz: [‘qux’, ‘quux’], corge: ‘’ }</p>
<h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><ul>
<li>url.parse(urlStr, [parseQueryString], [slashesDenoteHost])<br>urlStr-&gt;url字符串<br>parseQueryString-&gt;为true时将使用queryString分析查询字符串，默认为false<br>slashesDenoteHost<br>默认为false，//foo/bar 形式的字符串将被解释成 { pathname: ‘//foo/bar’ }<br>如果设置成true，//foo/bar 形式的字符串将被解释成  { host: ‘foo’, pathname: ‘/bar’ }</li>
</ul>
<p>服务器相关操作事件和API</p>
<ul>
<li>Event: ‘close’</li>
<li>Event: ‘connection’</li>
<li>Event: ‘request’</li>
<li>server.close([callback])</li>
<li>server.listen(port[, hostname][, backlog][, callback])</li>
</ul>
<p>请求对象</p>
<ul>
<li>Event: ‘data’</li>
<li>message.headers</li>
<li>message.httpVersion</li>
<li>message.method</li>
<li>message.url<ul>
<li>require(‘url’).parse(request.url)</li>
<li>require(‘url’).parse(request.url, true)</li>
</ul>
</li>
</ul>
<p>响应对象</p>
<ul>
<li>response.end([data][, encoding][, callback])</li>
<li>response.setHeader(name, value)</li>
<li>response.statusCode</li>
<li>response.statusMessage</li>
<li>response.write(chunk[, encoding][, callback])</li>
<li>response.writeHead(statusCode[, statusMessage][, headers])</li>
</ul>
<h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2><p>  <a href="http://www.gulpjs.com" target="_blank" rel="external">官网</a><br>  <a href="http://www.gulpjs.com.cn" target="_blank" rel="external">中文网</a></p>
<ul>
<li><p>前端自动化构建工具<br>js压缩,var x,xname，混淆<br>合并.<br>css压缩<br>html压压缩</p>
</li>
<li><p>grunt ,webpack…</p>
</li>
</ul>
<h3 id="核心就5个方法"><a href="#核心就5个方法" class="headerlink" title="核心就5个方法"></a>核心就5个方法</h3><ul>
<li>task,gulp中是一个个任务的形式来实现功能。<ul>
<li>task(‘任务名’,function(){<br>…..<br>});</li>
</ul>
</li>
<li>src<ul>
<li>src(‘./*.js’)</li>
</ul>
</li>
<li>dest(‘./minjs/‘)// 指定处理后的文件的输出路径.</li>
<li>watch(‘./*.js’,[‘任务名1’,’任务名2’]);</li>
<li>run(‘任务名’);//执行指定的任务.</li>
</ul>
<h3 id="gulp的安装"><a href="#gulp的安装" class="headerlink" title="gulp的安装"></a>gulp的安装</h3><ul>
<li>使用npm 进行安装</li>
<li><code>npm install gulp-cli -g</code>;</li>
<li><code>npm i -g gulp-cli</code>;</li>
</ul>
<h3 id="gulp-使用"><a href="#gulp-使用" class="headerlink" title="gulp 使用"></a>gulp 使用</h3><h4 id="使用时还需要在项目中通过npm非全局安装gulp"><a href="#使用时还需要在项目中通过npm非全局安装gulp" class="headerlink" title="使用时还需要在项目中通过npm非全局安装gulp"></a>使用时还需要在项目中通过npm非全局安装gulp</h4><ul>
<li><code>npm install gulp --save-dev</code></li>
</ul>
<h4 id="还需要在当前项目根目录添加一个gulpfile-js文件来写具体的任务代码"><a href="#还需要在当前项目根目录添加一个gulpfile-js文件来写具体的任务代码" class="headerlink" title="还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码."></a>还需要在当前项目根目录添加一个gulpfile.js文件来写具体的任务代码.</h4><h3 id="gulp的一些插件"><a href="#gulp的一些插件" class="headerlink" title="gulp的一些插件"></a>gulp的一些插件</h3><ul>
<li>也是使用npm安装</li>
<li>对js代码进行压缩 gulp-uglify<br>.pipe(uglify())</li>
<li>对代码进行合并 gulp-concat<br>.pipe(concat(‘all.js’))<br>.pipe(concat(‘all.css’))</li>
<li>对css进行压缩 gulp-cssnano<br>.pipe(cssnano())</li>
<li>对html进行压缩 gulp-htmlmin<br>.pipe(htmlmin({collapseWhitespace:true,minifyJS:false,minifyCSS:true}))</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-node02" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/17/node02/" class="article-date">
  	<time datetime="2016-04-17T12:24:22.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/node02/">
        node02
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>Node.js的特点？<br>适合高并发的场景、不适合cpu密集型场景<h2 id="1-2-cmd"><a href="#1-2-cmd" class="headerlink" title="1.2 cmd"></a>1.2 cmd</h2></li>
<li>cd（change directory）切换目录</li>
<li>md（make directory）新建目录</li>
<li>rd（remove directory）删除非空目录</li>
<li>dir（directory）查看目录中的条目<br><code>ls linux</code></li>
<li>ren（rename）重命名文件</li>
<li>del（delete）删除文件</li>
<li>cls（clear screen）清屏<br><code>clear linux</code></li>
</ul>
<h2 id="1-3-path-环境变量"><a href="#1-3-path-环境变量" class="headerlink" title="1.3 path 环境变量"></a>1.3 path 环境变量</h2><ul>
<li>path环境变量的作用是什么？</li>
<li>在Windows中配置path环境变量的方法是什么？</li>
</ul>
<h2 id="1-4-REPL（Read-Eval-Print-Loop）交互式运行环境"><a href="#1-4-REPL（Read-Eval-Print-Loop）交互式运行环境" class="headerlink" title="1.4 REPL（Read Eval Print Loop）交互式运行环境"></a>1.4 REPL（Read Eval Print Loop）交互式运行环境</h2><ul>
<li><p>作用：一般来说，可以用来做一些API的测试</p>
</li>
<li><p>进入REPL运行环境</p>
</li>
<li><p>退出REPL运行环境</p>
</li>
</ul>
<h2 id="1-5-Node-js基础知识"><a href="#1-5-Node-js基础知识" class="headerlink" title="1.5 Node.js基础知识"></a>1.5 Node.js基础知识</h2><ul>
<li>如何让Node.js执行一个js文件<br><code>node 文件名</code></li>
</ul>
<p>-绝对路径和相对路径<br>  <code>.\或者..\ 相对路径</code><br>  <code>c:/xx/xx.js绝对路径</code><br>  <code>\ linux 根目录
    windows 盘符的根目录</code><br>  不能夸盘符</p>
<h2 id="1-6-globals"><a href="#1-6-globals" class="headerlink" title="1.6 globals"></a>1.6 globals</h2><ul>
<li>__dirname和__filename<br><code>关于这俩家伙，一般在读取文件的时候，最好使用绝对路径的方式，通过这俩家伙拼接</code></li>
<li>console<ul>
<li>assert(foo==1,”失败”);断言 测试</li>
<li>time(‘timer’)</li>
<li>timeEnd(‘timer’)</li>
<li>成对的出现</li>
</ul>
</li>
</ul>
<h2 id="1-7-模块系统"><a href="#1-7-模块系统" class="headerlink" title="1.7 模块系统"></a>1.7 模块系统</h2><ul>
<li>什么是模块<br><code>一个文件就是一个模块</code></li>
<li>模块作用域<br><code>在一个模块内变量、函数、对象都属于这个模块，对外是封闭的。</code></li>
<li>require<br><code>require(&quot;路径&quot;)</code></li>
<li>exports<br><code>是module.exports的一个别名、引用，exports能做的module.exports都可以完成。</code></li>
<li>module.exports<br><code>最终曝露出去的对象，想曝露出去对象、属性、方法就挂载到module.exports</code></li>
</ul>
<p>#2.模块系统</p>
<p>##2.1模块的种类</p>
<p>在Node.js中，模块分为两类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">第一类，核心模块，node自带，用名称直接可以加载。</div><div class="line">- 核心模块</div><div class="line">  + fs file system</div><div class="line">  + http</div><div class="line">  + os</div><div class="line">  + path</div><div class="line">  + querystring</div><div class="line">  + url</div><div class="line">  ...</div><div class="line">第二类，文件模块，用路径加载，有一种特殊的文件模块-----&gt;包，可以用名字。</div></pre></td></tr></table></figure></p>
<p>module 是一个全局对象，它的作用是存储模块信息的,每一个js是一个模块，每一个模块里面都有一个module，module里面还存储了父子结构<br>直接给module.exports赋值，exports是无效，用属性的形式去赋值的时候二者都有效</p>
<h2 id="2-2-优先从缓存加载"><a href="#2-2-优先从缓存加载" class="headerlink" title="2.2 优先从缓存加载"></a>2.2 优先从缓存加载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">common.js-----&gt;加载后，再次加载时，去缓存中取module.exports</div></pre></td></tr></table></figure>
<h2 id="2-3-require参数解析"><a href="#2-3-require参数解析" class="headerlink" title="2.3 require参数解析"></a>2.3 require参数解析</h2><h3 id="require的加载流程"><a href="#require的加载流程" class="headerlink" title="require的加载流程"></a>require的加载流程</h3><p>1.判断是否在文件模块的缓存区中<br>  1.在  返回module.exports<br>  2.不在<br>     1.判断是否是原生模块（核心模块）<br>         1.是 判断是否在原生模块的缓存区中<br>            1.是 返回module.exports<br>            2.不是<br>               1.加载这个原生模块<br>               2.module对象加载到原生模块缓冲区中 返回module.exports<br>         2.不是 说明是文件模块<br>            1.查找，看文件模块是不是真的存在（不存在报错 can’t find module）<br>            2.加载这个文件模块<br>            3.缓存module对象加载到文件模块的缓冲区中 返回module.exports</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">核心模块是Node.js原生提供的加载核心模块的时候，</div><div class="line">不需要传入路径，因为Node.js已经将核心模块的文件代码</div><div class="line">编译到了二进制的可执行文件中了</div><div class="line">在加载的过程中，原生的核心模块的优先级是是最高的</div></pre></td></tr></table></figure>
<p><img src="./pic/image1.jpg" alt="Alt text"></p>
<ul>
<li><p>./或../开始的相对路径文件模块</p>
<figure class="highlight plain"><figcaption><span>和 你要加载的模块的文件名拼接 ```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 以/开始的绝对路径文件模块</div></pre></td></tr></table></figure>
<ul>
<li>在Linux或者MAc的操作系统中，/表示系统的根路径</li>
<li>在Windows中，/表示当前文件模块所属的根磁盘路径<br>不建议使用，了解<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- 标识符中可以不包含扩展名</div><div class="line">  + Node会按照`.js、.node、.json`的次序补足扩展名，依次尝试</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不包含扩展名的时候，Node.js会按照<br>  路径.js     以后自己在加载js文件模块的时候，就省略掉.js后缀就可以了<br>  路径.node   后缀为node的文件是c/c++写的一些扩展模块<br>  路径.json   如果是加载json文件模块，最好加上后缀.json，能稍微的提高一点加载的速度</p>
<pre><code>.json文件最终Node.js也是通过fs读文件的形式读取出来的，然后通过JSON.parse()转换成一个对象
</code></pre></li>
</ul>
<pre><code>Node.js会通过同步阻塞的方式看这个路径是否存在
依次尝试，直到找到为止，
如果找不到，报错
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- require 加载包的时候</div></pre></td></tr></table></figure>
<p>   直接写包名，先在包内的node_modules,<br>   目录下查找，去父级目录下的node_modules目录下查找，<br>   依次向上查找，直到根目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[参考文献](http://www.infoq.com/cn/articles/nodejs-module-mechanism/)</div><div class="line"># 3.包</div><div class="line">还有一种特殊的文件模块，其实就是包</div><div class="line">- 问题：你开的一个功能模块，还是以文件的形式散列的，你给别人使用的时候很麻烦。</div><div class="line">- 包的作用：在模块的基础上进一步组织JavaScript代码</div><div class="line"></div><div class="line">## 3.1 包的组成</div><div class="line">- 包结构</div><div class="line">- 包描述文件package.json</div><div class="line">  + 描述你的当前的包的一些相关的信息</div><div class="line">  +dependencies</div><div class="line">   -  包名：“版本号”</div><div class="line">   -  &gt; +版本号   下载大于某个版本号，npm会下最新版</div><div class="line">   -  &lt; +版本号   下载小于某个版本号，npm会下小于这个版本号最新版</div><div class="line">   -  &lt;= 小于等于 一定会下你写的这个版本，除非没有你写的这个版本</div><div class="line">   -  &gt;= 大于等于  下载最新版</div><div class="line">   -   *、&quot; &quot;、X  任意 npm会给你下最新版</div><div class="line">   -   ~ +版本号  会去下约等于这个版本的最新版，在大版本不变的情况下下一个比较新的版本</div><div class="line">   -   ^ +版本号  不跃迁版本下载，^2.1.0 npm会下载大版本不变，去下载2.x.x版本里的最近版</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  [参考文献 package.json全字段解析](http://blog.csdn.net/woxueliuyun/article/details/39294375)</div><div class="line"></div><div class="line">##</div><div class="line">npm install -g fast-init</div><div class="line">## 3.2 package.json</div><div class="line"></div><div class="line">包的描述文件</div><div class="line"></div><div class="line">package.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置，</div><div class="line">比如name就是项目名称，version就是项目的版本号</div><div class="line"></div><div class="line">在模块的加载机制中，有一个main属性是非常重要的，它很大意义上决定了包要导出的模块位置</div><div class="line"></div><div class="line">## 3.3</div><div class="line"></div><div class="line"># npm</div><div class="line">- 基于Node.js开发的包的托管网站</div><div class="line">- Node.js包管理工具</div><div class="line"></div><div class="line">npm :基于包的规范实现的一个包管理工具</div><div class="line"></div><div class="line">- npm install 包名</div><div class="line"></div><div class="line">当执行npm install的时候，它会自动跑到npm的网站，然后找到该包的github地址，</div><div class="line">找到之后，下载这个压缩包，然后在执行npm install的当前目录下找一个叫做node_modules目录</div><div class="line">如果找到，直接解压这个压缩包，到node_modules目录下</div><div class="line">如果找不到，则新建一个node_modules目录，解压到该目录</div><div class="line"></div><div class="line">- npm install</div><div class="line"></div><div class="line">当执行npm install的时候，会自动在当前目录中查找package.json文件</div><div class="line">如果找到，找里面的 dependencies 字段，安装该字段中所有依赖的项</div><div class="line"></div><div class="line">- npm install --save 生产环境</div><div class="line">npm i -S jquery@3.*</div><div class="line">咱们以后在做项目的时候，先初始化一个package.json文件，</div><div class="line">在安装第三方包依赖的时候，必须使用npm install --save express,添加依赖项到package.json文件中，</div><div class="line">实际就是添加到dependencies字段中</div><div class="line"></div><div class="line">- npm install -save-dev 开发环境</div><div class="line">npm i -D jquery@3.*</div><div class="line">咱们以后在做项目的时候，先初始化一个package.json文件，</div><div class="line">在安装第三方包依赖的时候，必须使用npm install --save express,添加依赖项到package.json文件中，</div><div class="line">实际就是添加到dependencies字段中</div><div class="line"></div><div class="line">-npm docs +包名 调出相关的文件</div><div class="line"></div><div class="line">[参考文献 npm的命令](https://docs.npmjs.com/)</div><div class="line"></div><div class="line"></div><div class="line"># npm 这种东西的最终的目的就是：让你的开发模式工程化，都依靠工具来管理</div><div class="line"># nvm npm nrm</div><div class="line">## 3m</div></pre></td></tr></table></figure></p>
<p>   nvm node版本的管理工具<br>   npm node的包管理工具<br>   nrm npm的数据源管理工具</p>
<pre><code>npm install -g nrm
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 开源项目开发介绍</div><div class="line"></div><div class="line">##</div><div class="line">github 这个网站代码的仓库网站，我们可以把代码存入这个网站。</div><div class="line">1.github 帮你管理代码</div><div class="line">2.公司在使用github做代码的仓库</div><div class="line">3.面试的时候会问（b格比较高的公司）</div><div class="line">github 开源力量做一个开源项目</div><div class="line"></div><div class="line">将成熟的代码打包放到npm 上去面，方便我们的使用</div><div class="line">#4.文件操作</div><div class="line">###4.1箭头函数</div></pre></td></tr></table></figure>
<p>箭头函数就是一种语法糖<br>语法糖是一种语法，用这种语法能尝到甜头，能是编程高效<br>当函数体有一个参数有返回值的时候</p>
<p>var foo=function(v){ return v;}</p>
<p>var foo=v=&gt;v;<br>当函数体没有参数有返回值的时候</p>
<p>var foo=function(){ return v;}</p>
<p>var foo=()=&gt;v;<br>当函数体有多个参数有返回值的时候</p>
<p>var foo=function(v1,v2){ return v1+v2;}<br>var foo=(v1,v2)=&gt;v1+v2;<br>当函数体有多个参数没有返回值的时候<br>var foo=function(v1,v2){<br>  console.log(v1); console.log(v2);<br>  }<br>var foo=(v1,v2)=&gt;{<br>  console.log(v1); console.log(v2);<br>  };</p>
<p>```</p>
<p>###4.2文件读写</p>
<ul>
<li>fs.readFile() 读文件</li>
</ul>
<p>fs.readFile(file, [options], callback)<br>//file 读文件的路径<br>//options 用[]包裹的可选参数，object {“encoding”:”uft8”,”flag”:”r”}  string ‘utf8’<br>//callback function  callback函数里面有两个参数<br>//err表示错误对象，如果readFile发生错误了，在callback函数里面会回返回err，err对象里面存着错误信息<br>//如何读文件成功，err为null<br>//data就是读文件，读出来的内容。</p>
<ul>
<li>fs.access(path,[mode], callback) 用来判断文件是否存在<br>//path 判断路径是否正确（也可以判断文件）’./pic’<br>//mode一般不用，默认就可以了，用的话是用来判断文件是否可读可写可执行<br>//callback 只有一个参数err，错，文件有问题</li>
<li>fs.writeFile()  写文件</li>
<li>fs.appendFile() 在文件的内部去追加写一些内容</li>
<li>fs.mkdir() 创建文件夹</li>
<li>fs.access() 判断路径</li>
<li><p>fs.stat()<br>isFile：用于判断被查看的对象是否为一个文件，如果是返回true，否则，返回false；<br>isDirectory：用于判断被查看的对象是否为一个目录，如果是的话则返回true，否则，返回false；</p>
</li>
<li><p>fs.readdir() 读一个路径</p>
</li>
</ul>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ul>
<li>vsc教程<a href="vsc教程">http://i5ting.github.io/vsc/</a></li>
</ul>
<p>#作业<br>2.npm 和package.json结合着连<br>npm init    初始化package.json<br>npm install   先配置package.json里的devDependencies dependencies字段<br>npm i -S +包名 npm install –save  不光能下载包，还能把依赖添加到package.json<br>npm i -D +包名 npm install –save-dev 不光能下载包，还能把依赖添加到package.json<br>npm docs 包名  查看包的相关文件 jquery、mongoose、http-poster<br>npm list 当前目录有什么包，检测node_modules里面有什么<br>npm install –g 包名  全局安装 cnpm、nrm<br>3.cnpm<br>4.nrm<br>安装目录npm install -g nrm<br>nrm ls 查看数据源<br>nrm test 测试你的网连那个npm的数据源快<br>nrm use 切换数据源<br>5.阅读参考文献 朴灵 require<br>阅读参考文献 package.json全字段解析</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-node03" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/17/node03/" class="article-date">
  	<time datetime="2016-04-17T12:24:22.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/node03/">
        node03
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-0-nvm常用命令"><a href="#1-0-nvm常用命令" class="headerlink" title="1.0 nvm常用命令"></a>1.0 nvm常用命令</h2><ul>
<li>nvm项目地址：<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">nvm-github地址</a></li>
<li>查看所有已安装的本地的node版本<br><code>nvm list</code></li>
<li>切换node版本<br><code>nvm use 版本号</code></li>
<li>安装指定版本的node<br><code>nvm install 版本号 位数</code></li>
<li>卸载已安装的指定版本的node<br><code>nvm uninstall 版本号</code></li>
</ul>
<p>###1.1模块的分类</p>
<figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- 核心模块</div><div class="line">  + fs file system</div><div class="line">  + http</div><div class="line">  + os</div><div class="line">  + path</div><div class="line">  + querystring</div><div class="line">  + url</div><div class="line"></div><div class="line">###1.2模块三兄弟 require、module、exports</div><div class="line"></div><div class="line">- require的实现原理</div><div class="line"></div><div class="line">```把代码从文件中读出来，用匿名函数的方式头尾包装，返回modules.exports对象，曝露出想要曝露出来的属性、方法、对象。</div><div class="line">   补充了exports是指向modules.exports的一个指针，exports能做的，modules.exports都能做的。</div></pre></td></tr></table></figure>
<ul>
<li>require查找文件、包原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">第二次加载的时候优先从缓存查找读取，</div><div class="line">node_modules中没有的，从父文件夹中查找，如果没有，直到根目录为止</div></pre></td></tr></table></figure>
<ul>
<li><p>module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">里面保存了模块的信息路径、父子信息、曝露出的对象信息</div></pre></td></tr></table></figure>
</li>
<li><p>exports</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports 别名</div><div class="line">module.exports=123;已经使用过一次了，exports就不生效了</div><div class="line">module.exports.a=12;这样使用,exports是还可以使用的</div></pre></td></tr></table></figure>
</li>
</ul>
<p>###1.4包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">package.json是包的说明书，</div><div class="line">dependencies当前包所依赖的包：&gt;、&lt;、&gt;=、&lt;=、~、*、&quot; &quot;、X、^</div><div class="line"> devDependencies 开发环境中包所依赖的包：</div></pre></td></tr></table></figure></p>
<p>###1.5npm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">npm init  创建package.json文件</div><div class="line">npm install  将package.json中的文件依赖的包从网上下载到本地</div><div class="line">npm install -save 包名  将包下载下来并且加载到dependencies中去</div><div class="line">npm i -S 包名 替代上面的命令</div><div class="line">npm install -save-dev 包名 将包下载下来并且加载到devDependencies中去</div><div class="line">npm i -D 包名 替代上面的命令</div><div class="line">npm install -g 包名 全局安装  安装的是全局工具</div><div class="line">npm docs 包名 查看包的文档</div></pre></td></tr></table></figure></p>
<p>###1.6nrm npm的数据源管理工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nrm ls 查看npm的数据源</div><div class="line">nrm use 切换npm下载包的地址</div><div class="line">nrm test  测试下哪个数据源快</div></pre></td></tr></table></figure></p>
<h3 id="1-7-3m"><a href="#1-7-3m" class="headerlink" title="1.7 3m"></a>1.7 3m</h3><p>npm node的包管理工具<br>nvm node的版本管理工具<br>nrm npm的数据源管理工具</p>
<p>###1.8箭头函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法糖替代function()&#123;&#125;  v=&gt;v</div></pre></td></tr></table></figure></p>
<p>#2.i/o</p>
<p>###2.1什么是i/o？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">io input、output 输入输出，电脑的输入输出，例如音频录音表示声音输入、听音乐是声音的输出</div><div class="line">网络上的传输全部是在传字符串，i/o在服务器上可以理解为读写操作。</div></pre></td></tr></table></figure>
<p>###2.2什么是并发？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个时间段中有几个程序都处于已启动运行到运行完毕之间。</div></pre></td></tr></table></figure></p>
<p>#3异步i/o与事件驱动</p>
<p>###3.1什么是进程？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">进程是为运行当中的应用程序提供运行环境的</div><div class="line">一个运行当中的应用程序就会有一个进程与之相对应</div></pre></td></tr></table></figure></p>
<p>###3.2什么是线程？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">线程是用来运行应用程序中代码的，</div><div class="line">一个线程在一个时间只能做一件事件。</div><div class="line">多线程，调度起来很麻烦。</div><div class="line">node是单线程执行，用异步替代了多线程</div></pre></td></tr></table></figure></p>
<p>###3.3同步、异步有什么不同？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">异步不会阻塞后面的代码，同步会阻塞后面的代码</div><div class="line">一条线程先执行同步的代码后执行异步的代码。</div></pre></td></tr></table></figure></p>
<p>###3.4异步非i/o操作和异步i/o操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">异步非io setTimeout setInterval</div><div class="line">异步IO操作 操作文件 网络操作 fs</div></pre></td></tr></table></figure></p>
<p>###3.5node的事件驱动模型？<br><img src="./pic/event-loop.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>###3.5异步和多线程的比较？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node的异步是帮助我们去做了多线程的操作，简化了代码</div></pre></td></tr></table></figure></p>
<p>#4.文件操作</p>
<p>###4.1文件的完整读写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs模块---》操作文件---》io----》node的特长</div><div class="line">fs模块是node非常重要的模块，能体现出node的优势</div></pre></td></tr></table></figure></p>
<ul>
<li>fs.readFile()  读文件</li>
<li>fs.writeFile()  写文件</li>
<li>fs.appendFile() 在文件的内部去追加写一些内容</li>
<li>fs.mkdir() 创建文件夹</li>
<li>fs.readdir() 读文件夹</li>
<li>fs.access() 判断路径</li>
<li>fs.stat()<br>isFile：用于判断被查看的对象是否为一个文件，如果是返回true，否则，返回false；<br>isDirectory：用于判断被查看的对象是否为一个目录，如果是的话则返回true，否则，返回false；<br>isBlockDevice：用于判断被查看的文件是否为一个块设备文件，如果是的话则返回true，否则，返回false(仅在Unix操作系统下有效)；<br>isCharacterDevice：用于判断被查看的文件是否为一个字符设备文件，如果是的话则返回true，否则，返回false(仅在Unix操作系统下有效)；<br>isSymbolicLink：用于判断被查看的文件是否为一个符号链接文件，如果是的话则返回true，否则，返回false。该方法仅在lstat方法的回调函数中有效；<br>isFIFO：用于判断被查看的文件是否为一个FIFO，如果是的话则返回true，否则，返回false(仅在Unix操作系统下有效)；<br>isSocket：用于判断被查看的文件是否为一个socket文件，如果是的话则返回true，否则，返回false(仅在Unix操作系统下有效)；</li>
</ul>
<p>#5.path</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-node04" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/17/node04/" class="article-date">
  	<time datetime="2016-04-17T12:24:22.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/node04/">
        node04
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-0-nvm常用命令"><a href="#1-0-nvm常用命令" class="headerlink" title="1.0 nvm常用命令"></a>1.0 nvm常用命令</h2><ul>
<li>nvm项目地址：<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">nvm-github地址</a></li>
<li>查看所有已安装的本地的node版本<br><code>nvm list</code></li>
<li>切换node版本<br><code>nvm use 版本号</code></li>
<li>安装指定版本的node<br><code>nvm install 版本号 位数</code></li>
<li>卸载已安装的指定版本的node<br><code>nvm uninstall 版本号</code></li>
</ul>
<p>###1.1模块的分类</p>
<figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- 核心模块</div><div class="line">  + fs file system</div><div class="line">  + http</div><div class="line">  + os</div><div class="line">  + path</div><div class="line">  + querystring</div><div class="line">  + url</div><div class="line"></div><div class="line">###1.2模块三兄弟 require、module、exports</div><div class="line"></div><div class="line">- require的实现原理</div><div class="line"></div><div class="line">```把代码从文件中读出来，用匿名函数的方式头尾包装，返回modules.exports对象，曝露出想要曝露出来的属性、方法、对象。</div><div class="line">   补充了exports是指向modules.exports的一个指针，exports能做的，modules.exports都能做的。</div></pre></td></tr></table></figure>
<ul>
<li>require查找文件、包原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">第二次加载的时候优先从缓存查找读取，</div><div class="line">node_modules中没有的，从父文件夹中查找，如果没有，直到根目录为止</div></pre></td></tr></table></figure>
<ul>
<li><p>module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">里面保存了模块的信息路径、父子信息、曝露出的对象信息</div></pre></td></tr></table></figure>
</li>
<li><p>exports</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports 别名</div><div class="line">module.exports=123;已经使用过一次了，exports就不生效了</div><div class="line">module.exports.a=12;这样使用,exports是还可以使用的</div></pre></td></tr></table></figure>
</li>
</ul>
<p>###1.4包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">package.json是包的说明书，</div><div class="line">dependencies当前包所依赖的包：&gt;、&lt;、&gt;=、&lt;=、~、*、&quot; &quot;、X、^</div><div class="line"> devDependencies 开发环境中包所依赖的包：</div></pre></td></tr></table></figure></p>
<p>###1.5npm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">npm init  创建package.json文件</div><div class="line">npm install  将package.json中的文件依赖的包从网上下载到本地</div><div class="line">npm install -save 包名  将包下载下来并且加载到dependencies中去</div><div class="line">npm i -S 包名 替代上面的命令</div><div class="line">npm install -save-dev 包名 将包下载下来并且加载到devDependencies中去</div><div class="line">npm i -D 包名 替代上面的命令</div><div class="line">npm install -g 包名 全局安装  安装的是全局工具</div><div class="line">npm docs 包名 查看包的文档</div></pre></td></tr></table></figure></p>
<p>###1.6nrm npm的数据源管理工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nrm ls 查看npm的数据源</div><div class="line">nrm use 切换npm下载包的地址</div><div class="line">nrm test  测试下哪个数据源快</div></pre></td></tr></table></figure></p>
<h3 id="1-7-3m"><a href="#1-7-3m" class="headerlink" title="1.7 3m"></a>1.7 3m</h3><p>npm node的包管理工具<br>nvm node的版本管理工具<br>nrm npm的数据源管理工具</p>
<p>###1.8箭头函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">语法糖替代function()&#123;&#125;  v=&gt;v</div></pre></td></tr></table></figure></p>
<p>#2.i/o</p>
<p>###2.1什么是i/o？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">io input、output 输入输出，电脑的输入输出，例如音频录音表示声音输入、听音乐是声音的输出</div><div class="line">网络上的传输全部是在传字符串，i/o在服务器上可以理解为读写操作。</div></pre></td></tr></table></figure>
<p>###2.2什么是并发？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个时间段中有几个程序都处于已启动运行到运行完毕之间。</div></pre></td></tr></table></figure></p>
<p>#3异步i/o与事件驱动</p>
<p>###3.1什么是进程？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">进程是为运行当中的应用程序提供运行环境的</div><div class="line">一个运行当中的应用程序就会有一个进程与之相对应</div></pre></td></tr></table></figure></p>
<p>###3.2什么是线程？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">线程是用来运行应用程序中代码的，</div><div class="line">一个线程在一个时间只能做一件事件。</div><div class="line">多线程，调度起来很麻烦。</div><div class="line">node是单线程执行，用异步替代了多线程</div></pre></td></tr></table></figure></p>
<p>###3.3同步、异步有什么不同？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">异步不会阻塞后面的代码，同步会阻塞后面的代码</div><div class="line">一条线程先执行同步的代码后执行异步的代码。</div></pre></td></tr></table></figure></p>
<p>###3.4异步非i/o操作和异步i/o操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">异步非io setTimeout setInterval</div><div class="line">异步IO操作 操作文件 网络操作 fs</div></pre></td></tr></table></figure></p>
<p>###3.5node的事件驱动模型？<br><img src="./pic/event-loop.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>###3.5异步和多线程的比较？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node的异步是帮助我们去做了多线程的操作，简化了代码</div></pre></td></tr></table></figure></p>
<p>#4.文件操作</p>
<p>###4.1文件的完整读写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs模块---》操作文件---》io----》node的特长</div><div class="line">fs模块是node非常重要的模块，能体现出node的优势</div></pre></td></tr></table></figure></p>
<ul>
<li>fs.readFile()  读文件</li>
<li>fs.writeFile()  写文件</li>
<li>fs.appendFile() 在文件的内部去追加写一些内容</li>
<li>fs.mkdir() 创建文件夹</li>
<li>fs.readdir() 读文件夹</li>
<li>fs.access() 判断路径</li>
<li>fs.stat()<br>isFile：用于判断被查看的对象是否为一个文件，如果是返回true，否则，返回false；<br>isDirectory：用于判断被查看的对象是否为一个目录，如果是的话则返回true，否则，返回false；<br>isBlockDevice：用于判断被查看的文件是否为一个块设备文件，如果是的话则返回true，否则，返回false(仅在Unix操作系统下有效)；<br>isCharacterDevice：用于判断被查看的文件是否为一个字符设备文件，如果是的话则返回true，否则，返回false(仅在Unix操作系统下有效)；<br>isSymbolicLink：用于判断被查看的文件是否为一个符号链接文件，如果是的话则返回true，否则，返回false。该方法仅在lstat方法的回调函数中有效；<br>isFIFO：用于判断被查看的文件是否为一个FIFO，如果是的话则返回true，否则，返回false(仅在Unix操作系统下有效)；<br>isSocket：用于判断被查看的文件是否为一个socket文件，如果是的话则返回true，否则，返回false(仅在Unix操作系统下有效)；</li>
</ul>
<p>#5.path</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-node05" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/17/node05/" class="article-date">
  	<time datetime="2016-04-17T12:24:22.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/node05/">
        node05
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-1node的调试"><a href="#1-1node的调试" class="headerlink" title="1.1node的调试"></a>1.1node的调试</h3><ul>
<li>前两样调试用于面试</li>
<li>node自带的debug调试命令 n下一步 s步入 o步出</li>
<li>node-debug foo.js node-inspector</li>
<li>vsc 推荐使用</li>
<li>vsc launch.json</li>
<li>抽风式的好使</li>
<li>ws<h3 id="1-2-es6"><a href="#1-2-es6" class="headerlink" title="1.2 es6"></a>1.2 es6</h3></li>
<li>用es新特性之前加上严格模式</li>
<li>什么是es？</li>
<li>为什么用es的新标准？</li>
<li>为什么前端不用，node要用？<br>es6定义了一个标准—-&gt;let命令—-&gt;js代码里面写了let—-&gt;v8引擎解析，能解析说明支持了es6里的let命令—-&gt;node升级了</li>
<li>严格模式</li>
<li>let</li>
<li>const</li>
<li>块级作用域{}<br>let foo =456;<br>{<br>let foo =123;<br>}<br>console.log(foo);</li>
<li>字符串的扩展  includes(str) startsWith(str) endsWith(str) repeat(num) <code>${变量名}</code><br>var bar=’暗示的反思’<br>var foo=’123’+’阿斯顿发斯蒂芬’+bar+’是短发飞’;<br>var foo2=<code>阿斯顿发斯蒂芬${bar}是短发飞</code></li>
<li>箭头函数、</li>
<li>let const 箭头函数 用来看api使用<h3 id="1-3-buffer"><a href="#1-3-buffer" class="headerlink" title="1.3 buffer"></a>1.3 buffer</h3></li>
<li>创建Buffer</li>
<li>Buffer的一些属性和方法</li>
<li>Buffer的一些属性和方法<ul>
<li>buf[index] 通过下标访问 buffer 的某个字节的数据</li>
<li>buf.indexOf(value,[byteOffset],[encoding]) 查找某个字符在 buffer 内存中的字节下标</li>
<li>buf.includes(value,[byteOffset],[encoding])</li>
<li>buf.length</li>
<li>buf.slice([start,[end]])</li>
<li>buf.toString([encoding],[start], [end])</li>
<li>buf.write(string,[offset],[length],[encoding])<h3 id="1-4-文件流"><a href="#1-4-文件流" class="headerlink" title="1.4 文件流"></a>1.4 文件流</h3></li>
</ul>
</li>
<li>流对象 stream</li>
<li>pipe（）<h2 id="2-网络编程"><a href="#2-网络编程" class="headerlink" title="2.网络编程"></a>2.网络编程</h2></li>
</ul>
<p>我们处于互联网时代，我们可以随时随地通过 Internet 上网、浏览新闻、玩LOL、上淘宝购物等等。<br>这些过程都发生了网络数据的交互。<br>bs browser server<br>cs client server</p>
<p>网络编程 是指<strong>编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。</strong><br>注意：这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。</p>
<p>强调：网络编程重在思想，node只是一个可以帮助我们网络编程的一个工具而已。<br>使用其他编程语言或者操作系统进行网络编程，思想都是一样的。</p>
<h3 id="什么是服务器？"><a href="#什么是服务器？" class="headerlink" title="什么是服务器？"></a>什么是服务器？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">服务器就是一个台电脑，是一台性能比较好的大电脑，它需要支持高扩展性，提供服务的</div><div class="line">服务器一旦部署好服务后，一般动的比较少，linux系统比较常用，不需要比较复杂的可视化操作界面，因为复杂的可视化操作系统比较耗资源，如win10，和windows相比linux比较安全</div><div class="line">服务器用linux的centos，ubuntu是有桌面版的</div><div class="line">服务器多用centos</div></pre></td></tr></table></figure>
<h3 id="什么是应用服务器？"><a href="#什么是应用服务器？" class="headerlink" title="什么是应用服务器？"></a>什么是应用服务器？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">作为服务器执行共享业务应用程序的底层的系统软件</div></pre></td></tr></table></figure>
<h3 id="什么是web服务器？"><a href="#什么是web服务器？" class="headerlink" title="什么是web服务器？"></a>什么是web服务器？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">web服务器是一种应用服务器，提供了web服务，对内提供web应用程序的的运行环境</div></pre></td></tr></table></figure>
<p>Apache、Nginx、IIS、tomcat</p>
<h3 id="Node-没有-Web-容器"><a href="#Node-没有-Web-容器" class="headerlink" title="Node 没有 Web 容器"></a>Node 没有 Web 容器</h3><p>如果我用js写了一个web应用程序，那么node就是web服务器<br>.net平台的 ASP或者ASP.net 需要 IIS 作为服务器容器，<br>PHP需要搭载 Apache 或者 Nginx 作为服务器容器，<br>Java 的 JSP 需要 tomcat 作为服务器容器，<br>ruby 的 ruby on rails 需要 搭配 Apache 等作为自己的服务器容器。。。</p>
<p>Node，不需要服务器容器。</p>
<p>Node，不需要服务器容器。</p>
<p>Node，不需要服务器容器。</p>
<h3 id="为什么叫-Node"><a href="#为什么叫-Node" class="headerlink" title="为什么叫 Node"></a>为什么叫 Node</h3><p>Node是一个面向网络而生的平台。</p>
<p>Ryan Dahl 在创建Node项目的时候给它起了一个名字叫做 web.js ，就是一个Web服务器。<br>类似于 Apache、tomcat、IIS 等服务器软件。</p>
<p>web.js 的发展超出了作者的最初想法，变成了构建网络应用的一个基础平台。<br>然后就可以在这个基础平台之上构建很多东西，比如服务器、客户端、各种各样的命令行工具等。</p>
<p>Node的目标就是成为一个构建快速、可伸缩的网络应用平台。</p>
<p>每一个Node进程构成网络应用中的一个节点。这就是 Node 的含义。</p>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nginx除了是个web服务器还能够做反向代理服务器，</div><div class="line">反向代理服务器的作用，可以用来做负载均衡</div><div class="line">代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。</div></pre></td></tr></table></figure></p>
<ul>
<li>可以用nginx来做负载均衡<h3 id="跨域的场景"><a href="#跨域的场景" class="headerlink" title="跨域的场景"></a>跨域的场景</h3>1.域名不同 （www.wuyou.com 和www.liuxi.com 即为不同的域名）<br>2.二级域名相同，子域名不同    （www.wuyou.wu.com www.liuxi.wu.com 为子域不同）<br>3.端口不同，协议不同  （ <a href="http://www.wuyou.com" target="_blank" rel="external">http://www.wuyou.com</a> 和<a href="https://www.wuyou.com属于跨域www.wuyou.con:8888和www.wuyou.con:8080" target="_blank" rel="external">https://www.wuyou.com属于跨域www.wuyou.con:8888和www.wuyou.con:8080</a>)</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li>双方或多方同意，并且达成共识，遵守这样的约束<h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3></li>
</ul>
<p>ip能够定位电脑，端口号可以定位一个应用程序<br>node 默认是3000 多了往上加</p>
<h2 id="2-http协议"><a href="#2-http协议" class="headerlink" title="2 http协议"></a>2 http协议</h2><h3 id="2-1在地址栏输入网址后页面是如何呈现的？"><a href="#2-1在地址栏输入网址后页面是如何呈现的？" class="headerlink" title="2.1在地址栏输入网址后页面是如何呈现的？"></a>2.1在地址栏输入网址后页面是如何呈现的？</h3><ul>
<li>DNS 把域名转化成ip DNS服务器来做这个事情 运营商提供的dns服务器</li>
<li><p>CDN 内容分发网络</p>
</li>
<li><p>输入 URL：<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a></p>
</li>
<li>DNS 域名解析<ul>
<li>计算机无法识别域名，计算机与计算机之间要想进行通信，必须通过ip地址用来定位该计算机所在的位置</li>
<li>在浏览器中，输入的ip地址或者域名，默认给你加了一个80端口号（对方的服务器监听的就是80端口）</li>
<li>158.12.25.652  域名就是为了好记</li>
<li>为了好记，所以我们的 万维网提供了 一个 域名这样的概念</li>
<li>当你输入了 ip 地址后，浏览器会自动去 找DNS域名解析服务器，</li>
</ul>
</li>
<li>将用户输入的地址封装成 HTTP Request 请求报文 发送到服务器<ul>
<li>浏览器将用户输入的 URL 地址根据HTTP协议 封装成了  http 请求报文（请求头+请求行+请求体）</li>
<li>该报文说白了也就是字符串而已，最终也要被转成了二进制数据再发送到服务器</li>
</ul>
</li>
<li>后台服务器接收到用户HTTP Request 请求报文<ul>
<li>后台服务器接收到 客户端发送给自己的数据（二进制数据）<ul>
<li>首先把二进制数据按照编码解析成字符，（人类可以识别的）</li>
<li>解析成字符之后，再按照 HTTP 协议规范中定义的格式解析出来</li>
</ul>
</li>
</ul>
</li>
<li>后台服务器处理用户请求信息<ul>
<li>当得到用户请求报文之后，根据请求报文中的 get、port或者 URL、或者URL中的查询字符串或者 请求体中的数据</li>
<li>根据用户的特定的请求数据做特定的处理</li>
</ul>
</li>
<li>后台服务器将相应结果封装到 HTTP Response 响应报文中 发送给客户端<ul>
<li>当我们解析和处理完用户请求报文消息之后</li>
<li>服务器开始将具体的 要发送给客户端的数据 根据 HTTP 协议规范 封装成 HTTP协议响应报文</li>
<li>响应头、响应字段、响应体</li>
<li>该数据说白了也是具有特定格式的字符串而已，最终这个字符串也要转换成二进制数据发送到客户端</li>
<li>发送到客户端也是通过 Socket（ip地址、端口号） 发送到了该客户单</li>
</ul>
</li>
<li>用户浏览器接收到响应后开始渲染html、css，解析和执行 JavaScript 代码<ul>
<li>当客户端解析到 服务器发送过来的 二进制数据</li>
<li>客户端浏览器也会将 二进制数据 根据编码类型解析成 字符串</li>
<li>然后根据 HTTP 协议，解析服务器发送过来的 响应报文</li>
<li>然后根据响应报文中的报文内容（报文头、报文体）做具体的解析</li>
</ul>
</li>
<li>当浏览器在解析的过程中遇到 一些静态资源时，会再次重复上面的步骤<h3 id="2-2HTTP协议"><a href="#2-2HTTP协议" class="headerlink" title="2.2HTTP协议"></a>2.2HTTP协议</h3>HTTP协议就是 浏览器 和 服务器 之间通信的一个数据格式规范</li>
</ul>
<p>在HTTP协议中，始终是以一种 一问一答 的形式在进行沟通和交流（数据交换）</p>
<p>服务器如果没有收到浏览器的请求消息，服务器永远不会主动的发送响应消息</p>
<p>浏览器不发出请求，服务器不会主动的发送响应</p>
<ul>
<li>浏览器发送请求数据到服务器</li>
<li>服务器解析浏览器发送的请求数据</li>
<li>服务器响应数据到客户端浏览器</li>
</ul>
<h3 id="2-3cookie-amp-session"><a href="#2-3cookie-amp-session" class="headerlink" title="2.3cookie&amp;session"></a>2.3cookie&amp;session</h3><ul>
<li>http是一个无状态的协议，每次去请求服务器的时候，服务器是不能记住客户端的</li>
<li>cookie 信物，客户端请求服务器了以后，服务器给客户端一个信物，下次客户端再请求服务器的时候，给服务器这个信物<pre><code>服务器就知道是哪个客户端了
缺点是，不能存储太多内容、不安全
</code></pre></li>
<li>session 存储在服务器端的，保存着用户信息的，和cookie搭配来使用，可以用cookie里面的key对应上session里面的值<pre><code>session可以存在内存或硬盘上都可以。
</code></pre><h3 id="2-4前后端分离"><a href="#2-4前后端分离" class="headerlink" title="2.4前后端分离"></a>2.4前后端分离</h3></li>
</ul>
<h3 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h3><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="通过-nodemon-实现-保存文件实时重启"><a href="#通过-nodemon-实现-保存文件实时重启" class="headerlink" title="通过 nodemon 实现 保存文件实时重启"></a>通过 nodemon 实现 保存文件实时重启</h3><ol>
<li>安装nodemon <code>npm install -g nodemon</code></li>
<li>基本使用 <code>nodemon server.js</code></li>
</ol>
<p>只要执行了上面的命令，那么当你修改了 server.js 那么nodemon会帮你自动重启 server</p>
<h3 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h3><p>pm2 帮你重启node应用的</p>
<p>###</p>
<ul>
<li>loaclhost</li>
<li>127.0.0.1</li>
<li>ip地址<br>##http模块</li>
</ul>
<p>res.writeHead(200,{“Content-Type”:”text/html;charset=utf-8”});</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-node01" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/17/node01/" class="article-date">
  	<time datetime="2015-11-17T12:24:22.000Z" itemprop="datePublished">2015-11-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/17/node01/">
        node01
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><ul>
<li>现实中的模块化<ul>
<li>生产效率高</li>
<li>维护方便，成本低</li>
</ul>
</li>
<li><p>程序中的模块化</p>
<ul>
<li>开发效率高 一次编写多次使用</li>
<li>方便维护了（维护的成本更低）模块之间有高耦合低内聚的特点</li>
</ul>
</li>
<li><p>为什么要在 程序 中使用 模块化的开发方式</p>
<ul>
<li>命名冲突</li>
<li>文件依赖<h3 id="定义模块-define"><a href="#定义模块-define" class="headerlink" title="定义模块 define"></a>定义模块 define</h3></li>
</ul>
</li>
<li>定义模块 define(function(){})</li>
<li>函数体内的方法属性都属于这个方法，对外有封装性;解决了命名冲突问题，使js代码有了封装性</li>
<li>直接调用 jQuery 插件等非标准模块的方法 <a href="http://my.oschina.net/briviowang/blog/208587" target="_blank" rel="external">http://my.oschina.net/briviowang/blog/208587</a></li>
</ul>
<h3 id="启动模块-seajs-use"><a href="#启动模块-seajs-use" class="headerlink" title="启动模块 seajs.use"></a>启动模块 seajs.use</h3><ul>
<li>加载入口模块，我们把define定义的js就叫模块</li>
<li>这个用于在html代码里面的加载<h3 id="加载模块-require"><a href="#加载模块-require" class="headerlink" title="加载模块 require"></a>加载模块 require</h3>-加载文件依赖、模块依赖的，用于define函数体内<h3 id="暴露接口-exports-和-module-exports"><a href="#暴露接口-exports-和-module-exports" class="headerlink" title="暴露接口 exports 和 module.exports"></a>暴露接口 exports 和 module.exports</h3></li>
<li>module.exports曝露出一个完整的对象，只能扔一次只能曝露出来一个</li>
<li>exports是module.exports的别名，可以用来单个属性、方法、对象的曝露，用.的形式,exports能做的事情module.exports也可以做</li>
</ul>
<p>##requirejs<br>与seajs的区别<br>requirejs是优先加载的<br>seajs是懒加载的，就是有拖延症，用的时候才加载<br><a href="http://www.requirejs.cn/" target="_blank" rel="external">http://www.requirejs.cn/</a></p>
<p>###4.浏览器中的JavaScript可以做什么？<br>操作dom 提交表单等等</p>
<p>###5.浏览器中的JavaScript不可以做什么？<br>js不能操作电脑的硬件</p>
<p>###6.浏览器与JavaScript是什么关系？</p>
<p>js引擎—-&gt;就是内核</p>
<p>引擎的第一特点： 转化<br>发动机—–&gt;汽油转化成动力   重点在转化</p>
<p>模板引擎—-&gt;模板+数据–转化–&gt;页面</p>
<p>js代码通过—&gt;js引擎—-转化–&gt;字节码或者机器码</p>
<p>引擎的第二特点：可移植性</p>
<p>###7.JavaScript只可以运行在浏览器中吗？<br>Js靠我们的js引擎解析<br>Node.js运行js  node给V8引擎包一层壳，黑匣子</p>
<p>java java<br>.net c#<br>php php<br>noode.js js</p>
<p>##什么是 Node?</p>
<ul>
<li><a href="">https://nodejs.org/en/</a></li>
<li>node是js运行环境基于v8引擎<br>特点用事件驱动模型、无阻塞的io模型<br>优势轻量、高效</li>
<li>node是门技术不是语言<br>java java<br>.net c#<br>node js</li>
<li>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.<ul>
<li>JavaScript runtime  JavaScript 运行时</li>
<li>Chrome’s V8 JavaScript engine Chrome 浏览器 V8 引擎</li>
<li>Node.js 是一个 构建于 谷歌的 Chrome 浏览器的 V8 引擎之上的一个 <code>JavaScript运行时</code> 环境</li>
<li>Node.js可以解析和执行 JavaScript 代码</li>
</ul>
</li>
<li>Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.<ul>
<li>event-driven  事件驱动模型</li>
<li>non-blocking I/O model  非阻塞IO模型  IO（input/output）输入与输出</li>
<li>lightweight[ˈlaɪtweɪt]  轻量级<ul>
<li>在软件开发行业中，轻量级标识褒义词</li>
<li>轻量级也就意味着 运行速度快</li>
<li>轻量级也就意味着有更好的 跨平台 特性（平台的差异性，兼容性）</li>
</ul>
</li>
<li>efficient[ɪˈfɪʃnt] 高效的</li>
<li>Node.js的 事件驱动和非阻塞IO模型使得Node.js本身非常的轻量和高效</li>
</ul>
</li>
<li>Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.<ul>
<li>package ecosystem npm  包生态系统 npm</li>
<li>largest  最大的</li>
<li>open source libraries 开源库<ul>
<li>理论意义上 开源就表示有成熟的社区，开放源代码</li>
</ul>
</li>
<li>Node.js 的npm包生态系统，是世界上 最大的 开源库 生态系统</li>
<li>以前的 客户端中 JavaScript 库 散列在互联网的各个地方</li>
<li>npm 就是 把大家经常使用的一些开源库 给 组织到了一起</li>
</ul>
</li>
</ul>
<p>Node 是一个可以解析和执行 JavaScript 代码的 运行时环境</p>
<ul>
<li>Node.js 的作者<ul>
<li>瑞恩.达尔</li>
</ul>
</li>
</ul>
<h3 id="Node-的实现结构"><a href="#Node-的实现结构" class="headerlink" title="Node 的实现结构"></a>Node 的实现结构</h3><ul>
<li>V8 JavaScript 解析执行引擎   ECMAScript</li>
<li>中间层 （提供了文件操作、网络操作登陆接口）更加接近操作系统的接口供开发人员使用</li>
<li>硬件层</li>
</ul>
<p>###谁在使用 Node</p>
<p>国内一些创业公司用用的比较多，功夫熊（做上门保健的，美甲、按摩）<br>国外的一些大公司都有使用：Facebook、Twitter、Google<br>国内的一些大公司：Alibaba（天猫所有的页面都是通过Node提供的服务）、Tencent、Baidu</p>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="3m安装法-nvm-npm-nrm"><a href="#3m安装法-nvm-npm-nrm" class="headerlink" title="3m安装法 nvm npm nrm"></a>3m安装法 nvm npm nrm</h3><h3 id="安装包的方式安装"><a href="#安装包的方式安装" class="headerlink" title="安装包的方式安装"></a>安装包的方式安装</h3><ul>
<li>问题1：安装了node 没有卸载 2:32和64搞混了 3：；拼写错误，路径错误——&gt;老师眼力</li>
<li>下载地址：</li>
<li>一路下一步 next</li>
<li>如何确认是否安装成功：<ul>
<li><code>win + r</code> ，然后输入 <code>cmd</code> ，然后敲回车 就可以进入 cmd 控制台</li>
</ul>
</li>
</ul>
<h3 id="nvm-安装和管理我们的-Node-js版本"><a href="#nvm-安装和管理我们的-Node-js版本" class="headerlink" title="nvm 安装和管理我们的 Node.js版本"></a>nvm 安装和管理我们的 Node.js版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">nvm的安装方式，node.js version manager 是一个node的版本管理工具</div><div class="line">为了解决node版本切换问题</div><div class="line">右键在此电脑上点击一下--》属性---》系统---》高级系统设置---》环境变量</div><div class="line">控制面板---》系统---》高级系统设置---》环境变量</div><div class="line">NVM_HOME---C:\dev\nvm</div><div class="line">NVM_SYMLINK--C:\dev\nodejs</div><div class="line">新建一个path     %NVM_HOME%;%NVM_SYMLINK%</div></pre></td></tr></table></figure>
<p>nvm 用法<br>查看版本号<br>nvm list<br>用哪个版本（已经下载过的版本）<br>nvm use 版本号<br>nvm use 版本号 32<br>下载相对应版本<br>nvm install 版本号<br>nvm install 版本号 32</p>
<p>nvm下载的是二进制版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 控制台基本使用</div><div class="line"></div><div class="line">允许用户可以在终端命令台中与操作系统交互，其实就是输入与输出</div><div class="line"></div><div class="line">### 如何打开cmd</div><div class="line"></div><div class="line">1. 通过 按 window 键，输入 `cmd` 打开cmd程序</div><div class="line">2. 通过 `win+r`  输入 `cmd`，敲回车就可以进入</div><div class="line"></div><div class="line">### 基本命令</div><div class="line"></div><div class="line">- `dir` directory 列出当前目录下所有的条目</div><div class="line">  + 别名 `ls` 在 powershell 中可以使用</div><div class="line">- `cd` change directory 切换目录</div></pre></td></tr></table></figure></p>
<p>切换到当前目录下的 Desktop 目录<br>当想切换到当前目录的时候，最好使用 cd ./ 相对路径的形式<br>C:\Users\iroc&gt;cd Desktop<br>C:\Users\iroc\Desktop&gt;</p>
<p>在Windows 上切换盘符：<br><code>d:</code></p>
<p>切换绝对路径之后再同一个盘符下才有效</p>
<p>切换到上一级目录<br>C:\Users\iroc\Desktop\code\seajs&gt;cd ../<br>C:\Users\iroc\Desktop\code&gt;</p>
<p>连续进入多级目录<br>C:\Users\iroc\Desktop\code&gt;cd seajs/a<br>C:\Users\iroc\Desktop\code\seajs\a&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- `cls` clear screen 清屏</div><div class="line">  + 别名 clear 在widnows中的 `powershell` 中可以使用</div><div class="line"></div><div class="line"> windows下的寻址用\反斜杠</div><div class="line"></div><div class="line">### path 环境变量</div><div class="line"></div><div class="line">目的是为了在控制台中的任何目录都可以快速打开或者使用该可执行文件</div><div class="line"></div><div class="line">环境变量就是用来存储系统级别的变量</div><div class="line"></div><div class="line">- 添加环境变量</div><div class="line">  + 我的电脑 -&gt; 右键选择属性 -&gt; 高级系统设置 -&gt; 切换到`高级`面板 -&gt; 环境变量</div><div class="line">  + 第一种方式：直接把可执行文件所属的目录 放到 PATH 环境变量中（如果没有PATH环境变量，自己新建）</div><div class="line">  + 第二种方式：新建一个环境变量，变量名规范：逻辑名_HOME 变量值：该可执行文件所属的目录</div><div class="line">  + 注意：无论是直接添加的路径还是引用的变量名，一定要用 英文的分号 区分开</div><div class="line">  + 引用变量名的时候，变量名两边都是 `%`</div><div class="line"></div><div class="line">`&gt; feiq`</div><div class="line">当你在控制台中输入一个程序的名字的时候，cmd 默认把它当成一个可执行文件去执行了，</div><div class="line">优先找当前目录下是否有没有一个叫做feiq.exe 的可执行文件，如果有，直接执行打开</div><div class="line">如果没有，cmd会进入 path 环境变量中 一个目录一个目录的挨着查找里面是否有该可执行文件</div><div class="line"></div><div class="line">## REPL(Read-eval-print-loop) 运行环境</div><div class="line"></div><div class="line">用来测试一下代码的，repl和chrome的控制台很像</div><div class="line"></div><div class="line">- 通过在控制台中输入 `node` 敲回车就可以计入 REPL 运行环境</div><div class="line">- 通过在REPL运行环境中 连续按两次 `Ctrl+C` 就可以退出 REPL 运行环境</div><div class="line"></div><div class="line">## 执行js文件</div><div class="line"> 用node执行js文件，文件在当前目录下----&gt;node +文件名</div><div class="line"> 如果不在当前目录下，node +文件路径的形式执行</div><div class="line"> 相对路径</div><div class="line"> ./当前路径</div><div class="line"> ../上级目录</div><div class="line"> 绝对路径执行js的方式</div><div class="line"> node c:\Users\cena\Desktop\code\01helloworld.js</div><div class="line">## Global</div><div class="line">global和window很像，都是全局对象</div><div class="line">## CONSOLE</div></pre></td></tr></table></figure></p>
<p>断言 是用来测试用的<br>断言就是假定一个条件，如果条件成立则不输出任何内容，如果条件不成立则报错还要输出想要输出的内容。<br>console.assert(条件,条件不成立输出的内容);<br>var foo=3;<br>console.assert(foo==3,”失败”);<br>time() timeEnd()成对出现，计算在两个方法中间的代码的运行时间，传入的参数要一致<br>console.time(‘test’);</p>
<p>console.timeEnd(‘test1’);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### __dirname 和 __filename</div><div class="line">__dirnamee 用来找到当前文件夹的路径</div><div class="line">__filename 用来去到当前文件的路径</div><div class="line">不知道代码要才哪使用的时候，用于灵活的写代码取路径的时候。</div><div class="line">它们属于模块作用域，可以直接使用</div><div class="line">它们两个用来获取路径的，一般用于操作文件路径的时候，才会用到</div><div class="line"></div><div class="line">## process</div><div class="line"></div><div class="line">process 是一个全局可用对象，用来和我们现在启动中的node进行交互的</div><div class="line"></div><div class="line">process.version取版本号</div><div class="line">在控制台做标准输出</div><div class="line">process.stdout.write(`123123`);</div><div class="line">process.pid：当前进程的进程号。</div><div class="line">process.version：Node的版本，比如v0.10.18。</div><div class="line">process.platform：当前系统平台，比如Linux。</div><div class="line">process.env：指向当前shell的环境变量，比如process.env.HOME。</div><div class="line">process.stdout：指向标准输出。</div><div class="line">process.stdin：指向标准输入。</div><div class="line">process.stderr：指向标准错误。</div><div class="line">## 模块系统</div><div class="line">## node.js模块化</div></pre></td></tr></table></figure></p>
<p>一个js文件在node里面我们就理解为一个模块<br>require用来加载模块<br>module.exports用来曝露属性和方法的，因为模块有封装性，需要打破封装性曝露方法和属性来<br>exports是module.exports的别名，exports可以做的事情，module.exports都可以做，exports只能用.的形式曝露属性和方法<br>```</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2016 Dengbinbin
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/winnerweb/hexo-Yilia-Smackdown" target="_blank">Yilia(Smackdown)</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>